#!/usr/bin/perl -w


# This file shows how to use syntactical sugar additions to Perl to
# make the code from the file `tailcalls` look better.

# ------------------------------------------------------------------
use strict; use warnings FATAL => 'uninitialized';

use Cwd 'abs_path';
our ($mydir, $myname); BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/../lib";

use Chj::Backtrace;
use Chj::repl;

# This needs `Method::Signatures`, which is likely packaged
# (libmethod-signatures-perl in Debian), and `Sub::Call::Tail` which
# you'll probably have to install from CPAN:

# run `cpan`, then (perhaps after configuration, just say `yes`):
# [`install Method::Signatures` and] `install Sub::Call::Tail`

# This gives the 'func' keyword, to avoid having to pick up arguments
# explicitely from @_
use Method::Signatures;

# This gives the 'tail' keyword, to avoid having to use 'goto' and @_
# assignments
use Sub::Call::Tail;

# ------------------------------------------------------------------

# again, see (4b) in `basics` for basic explanations

func functional_fact ($x) {
    functional_fact_iter($x, 1)
}

our @functional_inspect;

func functional_fact_iter ($x, $res) {
    push @functional_inspect, fun {
	($x,$res)
    };
    if ($x < 2) {
	return $res;
    } else {
	# This is a tail call. Instead of doing it unoptimized like:
	#
	#  functional_fact_iter($x - 1,  $x * $res)
	#
	# we could be making use of Perl's goto $subroutine feature (see
	# `perldoc -f goto`):
	#
	# @_=($x - 1,  $x * $res);
	# goto \&functional_fact_iter
	#
	# or, with nicer looks, by using Sub::Call::Tail:
	tail functional_fact_iter($x - 1,  $x * $res)
    }
}


# To really see the difference, here's a function that works for
# higher number of iterations:

func odd ($n) {
    if ($n == 0) {
	0
    } else {
	even ($n - 1)
    }
}

func even ($n) {
    if ($n == 0) {
	1
    } else {
	odd ($n - 1)
    }
}

# $ ulimit -S -v 200000; ./tailcalls
# main> even 4
# $VAR1 = 1;
# main> even 5
# $VAR1 = 0;
# main> even 500
# Deep recursion on subroutine "main::even" at ./tailcalls line 65.
# Deep recursion on subroutine "main::odd" at ./tailcalls line 74.
# $VAR1 = 1;
# main> even 500000
# Deep recursion on subroutine "main::even" at ./tailcalls line 65.
# Deep recursion on subroutine "main::odd" at ./tailcalls line 74.
# Out of memory!

# You can see that Perl ran out of space for the stack.


func opt_odd ($n) {
    if ($n == 0) {
	0
    } else {
	tail opt_even ($n - 1);
    }
}

func opt_even ($n) {
    if ($n == 0) {
	1
    } else {
	tail opt_odd ($n - 1);
    }
}

# $ ulimit -S -v 200000; ./tailcalls
# main> opt_even 5000000
# $VAR1 = 1;

# Now it runs with little (and constant) memory usage.


# ------------------------------------------------------------------
# enter the repl for your experiments, see (0) in `basics`

repl;
