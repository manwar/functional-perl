#!/usr/bin/env perl

#
# Copyright (c) 2002,2014-2015 Christian Jaeger, copying@christianjaeger.ch
#
# This is free software, offered under either the same terms as perl 5
# or the terms of the Artistic License version 2 or the terms of the
# MIT License (Expat version). See the file COPYING.md that came
# bundled with this file.
#

use strict; use warnings; use warnings FATAL => 'uninitialized';

# before the introduction of any lexical variables:
sub myxeval_in {
    #my ($package,$str)=@_; nah, don't want them to be visible as
    #  lexicals
    #my $res; # aww, now we've got one anyway, stupid. Oh, can do:
    local $_;
    eval "package $_[0]; \$_= do { $_[1] }; 1"
      or die $@;
    $_
}

use Cwd 'abs_path';
our ($mydir, $myname); BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/../lib";


sub usage {
    print "$myname [ calculation(s) ]

  Repl-Enhanced PerL

  Evaluates the given string(s), or goes into interactive mode if
  none given.

  Interactive mode tricks:
  - enter alone re-evaluates last entry. No need to push cursor up for that:)
  - you can use \$variables (there's no strict vars in scope), or define
    subroutines, whatever...:)
  - you can refer to '\$VAR1' etc. to get the correspondin result from the
    previous entry (as long as you're using the default ':d' display mode)
  - enter ':?' to get a list of special commands and mode switches

  Options:
  -t               trap exceptions in a repl, too
  -H|--no-history  Do not save history to file.
                   (It is still being read in on startup.)
";
exit @_;
}

use Chj::xhome qw(xsafehome);

my $HISTFILE= xsafehome."/.${myname}_history";
my $MAXHISTLEN= 100;

my @files;
my $opt_H;
my @opt_M;
my $opt_t;
for (my $i=0; $i<=$#ARGV; $i++) {
    local $_=$ARGV[$i];
    if (/^--?h(elp)?$/) {
	usage
    } elsif ($_ eq '--') {
	push @files, @ARGV[$i+1..$#ARGV];
	last;
    } elsif ($_ eq '-H' or $_ eq '--no-history') {
	$opt_H=1;
    } elsif ($_ eq '-t') {
	$opt_t=1;
    } elsif (/^-M(.*)/) {
	if ($1) {
	    push @opt_M,$1;
	} else {
	    my $arg= $ARGV[++$i];
	    defined $arg or usage "missing argument to -M";
	    push @opt_M,$arg;
	}
    } elsif (/^-/) {
	warn "Unknown option '$_'\n";
	usage(1)
    } else {
	push @files, $_
    }
}


eval {
    require Chj::BinHexOctDec;
};
warn $@ if $@;

use Chj::WithRepl qw(push_withrepl WithRepl_eval);

push_withrepl (0)
  if $opt_t;

if (@opt_M) {
    require 'Chj/Package/OfPath.pm';
    Chj::Package::OfPath->import('package_of_path_or_package');

    my $code=
      join(";",
	   map { "use $_" }
	   map {
	       my $a=$_;
	       $a=~ s/([^=]+)//s
		 or die "invalid -M option '$_'";
	       my $path_or_package= $1;
	       my $p= package_of_path_or_package($path_or_package);
	       if ($a=~ s/^=//s) {
		   $p." ".join(", ",map{"'$_'"} split /,/,$a)
	       } else {
		   $p
	       }
	   }
	   @opt_M
	  );

    &WithRepl_eval ("package $myname; "
		    .$code
		    ."; 1")
      or die $@;
}


if (@files) {
    for (@files) {
	my $res= myxeval_in $myname, $_;
	print "$res\n";
    }
}

else {
    require Chj::Repl;
    my $repl= new Chj::Repl;
    $repl->set_historypath($opt_H ? undef : $HISTFILE);
    $repl->set_maxhistlen($MAXHISTLEN);
    $repl->set_package($myname);
    eval "package $myname; use Data::Dumper;";
    $repl->run;
}

