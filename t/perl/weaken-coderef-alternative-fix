#!/usr/bin/env perl

use strict; use warnings; use warnings FATAL => 'uninitialized';

use Scalar::Util 'weaken';

@ARGV==3 or die "usage: $0 impl n m";
our ($impl, $n, $m) = @ARGV;

sub fix ($);

*fix= [
    # choice of implementations

    # Y combinator
    do {
	my $fix0= sub {
	    my ($fix0, $f)=@_;
	    sub {
		@_=(&$fix0 ($fix0, $f), @_); goto $f;
	    }
	};
	sub ($) {
	    my ($f)=@_;
	    &$fix0 ($fix0, $f)
	}
    },

    # self-referencing through package variable
    sub ($) {
	my ($f)=@_;
	sub {
	    #@_=(fix ($f), @_); goto $f;
	    unshift @_, fix ($f); goto $f;
	}
    },

    # locally self-referencing 
    sub ($) {
	my ($f)=@_;
	my $f2; $f2= sub {
	    unshift @_, $f2; goto $f
	};
	my $f2_=$f2; weaken $f2; $f2_
    },

    ]->[$impl];


sub naturals {
    my $f; $f= sub {
	my ($n)= @_;
	my $f=$f;
	sub {
	    if ($n > 0) {
		[ $n, &$f($n - 1) ]
	    } else {
		undef
	    }
	}
    };
    my $f_= $f; weaken $f;
    goto $f_;
}

sub stream_sum {
    my ($s)=@_;
    weaken $_[0];
    # ^ not necessary here, since, unlike with FP::Lazy::Promise,
    # resulting value is not saved in its 'generating container'
    my $lp; $lp= sub {
	my ($tot,$s)=@_;
	weaken $_[1];
	if (my $fs= &$s) {
	    @_=($$fs[0] + $tot, $$fs[1]); goto $lp;
	} else {
	    $tot
	}
    };
    @_=(0, $s); my $lp_=$lp; weaken $lp; goto $lp_;
}


my $res;
for (1..$m) {
    my $ns= naturals $n;
    $res= stream_sum $ns;
}

print $res,"\n";

