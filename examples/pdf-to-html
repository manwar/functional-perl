#!/usr/bin/env perl

# Copyright (c) 2015 Christian Jaeger, copying@christianjaeger.ch
# This is free software. See the file COPYING.md that came bundled
# with this file.

use strict; use warnings; use warnings FATAL => 'uninitialized';
use Function::Parameters qw(:strict);

# find modules from functional-perl working directory (not installed)
use Cwd 'abs_path';
our ($mydir, $myname); BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/../lib";


sub usage {
    print "usage: $myname file.pdf outdir

   Convert a pdf file to SVG images (by way of `pdf2svg`) and a set of
   html pages embedding them.
";
    exit 1;
}

use Getopt::Long;
my $verbose=0;
my $opt_single;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "single-page"=> \$opt_single,
	   ) or exit 1;
usage unless @ARGV==2;

my ($infile,$outdir)= @ARGV;

use FP::IOStream qw(xdirectory_paths);
use FP::List qw(list cons);
use FP::Stream qw(Keep);
use Chj::xperlfunc qw(xstat xxsystem xunlink basename dirname);
use FP::Combinators qw(compose_scalar);
use FP::Ops qw(the_method number_cmp);
use PXML::XHTML ':all';
use PXML::Serialize qw(puthtmlfile);
use FP::Array_sort qw(on);
use Chj::xIOUtil qw(xputfile_utf8);

if ($ENV{DEBUG}) {
    require Chj::Trapl; # includes Chj::repl
} else {
    require Chj::Backtrace; import Chj::Backtrace;
    # XX should Backtrace be activated by load, not import?
}


fun regex_match ($re) {
    fun ($str) {
	$str=~ /$re/
    }
}

fun regex_substitute ($re,$sub) {
    fun ($str) {
	$str=~ s/$re/&$sub()/e;
	$str
    }
}

sub note {
    print STDERR "$myname: note: ",@_,"\n";
}

fun css_link ($src) {
    LINK ({rel=> "stylesheet",
	   href=> $src,
	   type=> "text/css"})
}


# svgfile and html paths

our $svgfile_template= 'page-%02d.svg';
our $svgpath_re= qr{(^|.*/)page-(\d+)\.svg$}s;
*svgpath_to_htmlpath= regex_substitute($svgpath_re, sub{"$1/page-$2.html"});
*svgpath_to_pageno= regex_substitute($svgpath_re, sub{$2+0});

our $css_src= "$myname.css";


# CSS contents

my $css_code= '
ul.menu {
  border: 1px solid #000;
  background-color: #eee;
  padding: 5px;
  list-style: none;
  padding-left: 0.5em;
}
li.menu {
  border-right: 1px solid #000;
  list-style: none;
  padding-left: 0.5em;
  padding-right: 0.3em;
  display: inline;
}
li.menu_last {
  list-style: none;
  padding-left: 0.5em;
  padding-right: 0.3em;
  display: inline;
}
';


fun svgpaths ($dir) {
    xdirectory_paths ($dir)
      ->filter (regex_match $svgpath_re)
	->sort(on *svgpath_to_pageno, *number_cmp)
	  # XX: HACK: since our libraries are not consistent enough
	  # (there's no "cons" method on PureArray, also, when to do
	  # lazy? Ok just prefix stream_ then? Also missing), we do:
	  ->stream
}


# ------------------------------------------------------------------
# file conversion

fun possibly_symlink ($old,$new) {
    symlink $old, $new
      or note "could not add symlink at $outdir/index.html: $!";
}

# wrapper just because Perl's core ops can't be passed by *
fun possibly_unlink ($path) {
    unlink $path
}

# convert pdf to svg unless already done
fun possibly_do_pdf2svg ($infile,$outdir) {
    my $outfiles= svgpaths($outdir);
    my $t_in= sub{ xstat($infile)->mtime };
    my $t_oldest= sub {
	Keep($outfiles)->map(compose_scalar the_method("mtime"), *xstat)->min
    };

    if ($outfiles->is_null or &$t_in >= &$t_oldest) {
	$outfiles->for_each(*xunlink);
	xxsystem "pdf2svg", $infile, "$outdir/$svgfile_template", 'all';
	1
    } else {
	0
    }
}


fun navigation_html ($svgpaths, $for_svgpath, $opt_single) {

    my $ul=
      UL({class=> "menu"},
	 $svgpaths->map_with_islast
	 (fun ($is_last, $svgpath) {
	     my $pageno= svgpath_to_pageno($svgpath);

	     my $href= $opt_single ? "#p$pageno" :
	       basename svgpath_to_htmlpath ($svgpath);

	     LI({class=> ($is_last ? "menu_last" : "menu")},
		($svgpath eq $for_svgpath ?
		 SPAN({class=> "menu_selected"}, $pageno)
		 : A({href=> $href},
		     $pageno)))
	 }));

    $opt_single ?
      A({name=> "p".svgpath_to_pageno($for_svgpath)},
	$ul)
      : $ul
}


# pure function that returns the actions to be taken (this allows us
# to inspect them before their execution, for debugging or testing):

fun _svgpaths_to_html_actions ($svgpaths, $title, $outdir) {
    # Will need to protect $svgpaths with `Keep` here since we're
    # using it multiple times

    # the html fragment for one page from the pdf
    my $page_htmlfragment= fun ($is_last, $for_svgpath) {
	# sub needed to work around destruction of document by
	# weakening done in serializer (ugly, really replace all
	# weakening and Keep stuff with a fixed perl?)
	my $TR_TD_nav=
	  sub { TR
		  TD {align=> "center"},
		    navigation_html($svgpaths, $for_svgpath, $opt_single) };
	[
	 &$TR_TD_nav,
	 TR(TD(IMG +{src=> basename($for_svgpath),
		     width=> "100%"})),
	 $opt_single ? ($is_last ? (TR TD HR) : ()) : &$TR_TD_nav
	]
    };

    my $html= fun ($title, $body) {
	HTML({lang=>'en'}, # XX should not assume 'en' (use HTML5)
	     HEAD (TITLE ($title),
		   css_link($css_src)),
	     BODY (TABLE({width=> "100%",
			  border=> 0},
			 $body)))
    };

    cons([ *xputfile_utf8, "$outdir/$css_src", $css_code ],

	 $opt_single ?
	 # all PDF pages in a single HTML page
	 list([*possibly_unlink,
	       "$outdir/index.html"],
	      [
	       *puthtmlfile,
	       "$outdir/index.html",
	       &$html($title,
		      Keep($svgpaths)->map_with_islast($page_htmlfragment))
	      ])
	 :
	 # one HTML page per PDF page
	 cons([
	       *possibly_symlink,
	       basename(svgpath_to_htmlpath($svgpaths->first)),
	       "$outdir/index.html"
	      ],
	      Keep($svgpaths)->map
	      (fun ($svgpath) {
		  [
		   *puthtmlfile,
		   svgpath_to_htmlpath($svgpath),
		   &$html("$title - page ".svgpath_to_pageno($svgpath),
			  &$page_htmlfragment(0, $svgpath)),
		  ]
	      })))
}


fun svgpaths_to_html_actions () {
    _svgpaths_to_html_actions(svgpaths($outdir),
			      basename($infile),
			      $outdir)
}

fun pdf_to_html () {
    mkdir $outdir;

    possibly_do_pdf2svg ($infile,$outdir)
      or note "svg files are up to date";

    svgpaths_to_html_actions->for_each
      (fun ($action) {
	  my ($proc, @args)= @$action;
	  &$proc(@args)
      });
}



$ENV{DEBUG} ? Chj::repl() : pdf_to_html ();

