#!/usr/bin/env perl

use strict; use warnings; use warnings FATAL => 'uninitialized';

# XX this file should be split into modules

# Method::Signatures versions 20120523 and 20141021 are working badly
# for this file, because (1) each package needs its own import, (2)
# error locations are completely off. Thus, still use the trusty
# Function::Parameters.

use Function::Parameters qw(:strict);
use Sub::Call::Tail;
use Chj::Backtrace;

# find modules from functional-perl working directory (not installed)
use Cwd 'abs_path';
our ($mydir, $myname); BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/../lib";


our $css_path= "htmlgen.css";

sub usage {
    print "$myname config inbase outbase

  config is the path to a Perl file ending in a hash with config
  values, see gen-ml2json.pl for an example.

  inbase needs to be a git working directory.

  Assumes that there is a file '$css_path', which is included in the
  <head/> and copied to outbase.

  Options:
    --repl  open a repl instead of running the main action
    --trap  trap uncached exception in a repl (implied by --repl)

";
    exit 1;
}

use Getopt::Long;
our $verbose=0;
our ($opt_repl,$opt_trap);
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "repl"=> \$opt_repl,
	   "trap"=> \$opt_trap,
	   ) or exit 1;
usage unless @ARGV==3 or ($opt_repl and @ARGV>=1);

our ($configpath, $inbase, $outbase)= @ARGV;

our $user_config= require $configpath;

mkdir $outbase;

use Hash::Util 'lock_hash';
use Text::Markdown 'markdown';
use Chj::IO::Command;
use Chj::xperlfunc ':all';
use Chj::xopen ":all";
use Chj::chompspace;
use Chj::xIOUtil qw(xputfile_utf8 xgetfile_utf8 xcopyfile);
use FP::HashSet ":all";
use PXML::XHTML ":all";
use FP::Array ":all";
use File::Spec;
use FP::Array_sort;
use FP::Ops qw(string_cmp number_cmp the_method);
use Chj::TEST ":all";
use FP::List ":all";
use FP::Lazy ":all";
use FP::Stream ":all";
use PXML "is_pxml_element";
use PXML::Util ":all";
use FP::Hash ":all";
use FP::Div qw(identity inc dec);
use PXML::Tags qw(with_toc);
use FP::fix;
use FP::StrictList;
use FP::Combinators ":all";
use FP::Predicates;

# move to lib
use File::Spec;
use Chj::Path;
use Chj::TEST ":all";

fun url_add ($base,$rel) {
    Chj::Path->new_from_string($base)->add
	(Chj::Path->new_from_string($rel), 1)
	  ->string
}

TEST{url_add "/foo", "/zoo" } "/zoo";
TEST{url_add "/foo", "../zoo" } "/zoo";
TEST{url_add "/foo", "zoo/loo" } "/foo/zoo/loo";
TEST{url_add "/foo", "zoo//loo/." } "/foo/zoo/loo/";
TEST{url_add ".", "zoo/loo" } "zoo/loo"; # definitely
TEST_EXCEPTION {url_add ".", "../zoo/loo" }
  # "../zoo/loo"; # yes that's something I want, ok?
  "can't take '..' of root directory"; # well, ok?


fun url_diff ($path0from,$path0to) {
    my $from= $path0from=~ m|(.*?)/+$|s ? $1 : dirname $path0from;
    File::Spec->abs2rel($path0to, $from);
}

TEST{url_diff "foo/", "bar.css"} '../bar.css';
TEST{url_diff "foo/bar.html", "bar.css"} '../bar.css';
TEST{url_diff "foo", "bar.css"} 'bar.css';
#TEST{url_diff ".", "bar.css"} 'bar.css';

#/lib

use Chj::CPAN::ModulePODUrl 'perhaps_module_pod_url';
our $podurl_cache= ".ModulePODUrl-cache"; mkdir $podurl_cache;
use FP::Memoizing 'memoizing_to_dir';
*xmaybe_module_pod_url=
  memoizing_to_dir $podurl_cache, \&perhaps_module_pod_url;

fun maybe_module_pod_url ($v) {
    my $res;
    eval {
	$res= xmaybe_module_pod_url ($v);
	1
    } || do {
	my $e= $@;
	my $firstline= "$e"; $firstline=~ s/\n.*//s;
	$firstline =~ m/Can't connect/i ? do {
	    warn "could not look up module '$v': $firstline";
	    return undef;
	}
	  : die $e
    };
    $res
}

our $default_config=
  +{
    is_indexpath0 => fun ($path0) {
	my $bn= lc basename($path0);
	$bn eq "index.md" or $bn eq "readme.md"
    },
   };


our $config = hashset_union ($user_config, $default_config);

lock_hash %$config;


# escape parentheses since URI doesn't do that itself, and we'd have a
# problem with the [text](uri) markdown syntax (is that the right way
# to escape in markdown? isn't it all hacky?)
fun parens_uri_escape ($str) {
    $str=~ s|\(|%28|sg;
    $str=~ s|\)|%29|sg;
    $str
}

# and for text display we need to *decode* URIs..
# COPY from chj-bin's `urldecode`
use Encode;
sub url_decode {
    my ($str)=@_;
    my $u= URI->new($str);
    my $str2= $u->uri_unescape;
    decode("utf-8", $str2, Encode::FB_CROAK)
}

# escape [ ] for markdown; XX is this correct?
fun squarebracked_escape ($str) {
    $str=~ s%([\[\]])%\\$1%sg;
    $str
}

# operating on markdown source string
fun mediawiki_expand ($str) {
    $str=~ s%(?<=[^\\])\[\[(.*?[^\\])\]\]%
	my $cont= $1;
        $cont=~ s|(?<=[^\\])\\(.)|$1|sg; # remove quoting
	my @parts= map { chompspace $_ } split /(?<=[^\\])\|/, $cont;
	if (@parts==1) {
	    my ($docname_and_perhaps_fragment)= @parts;
	    my $uri= URI->new($docname_and_perhaps_fragment);

	    my $fragment= url_decode $uri->fragment;
	    my $fragmenttext= do {
		if (length $fragment) {
		    my @f= split /,/, $fragment;
		    my $f= shift @f;
		    while (@f and length $f < 20 and length $f[0] < 20) {
			$f.= ",".shift @f;
		    }
		    $f.= ".." if @f;
		    if (length $f > 40) {
			$f= substr ($f, 0, 28). ".."
		    }
		    " ($f)";
		} else {
		    ""
		}
	    };

	    # (Get title of document at path? But may be too long,
	    # probably not a good idea.)

	    # XX use 'opaque' instead of 'path' for the url? for
	    # locations with protocol or so? Or croak about those? Use
	    # opaque for the text, though, ok?
	    my $text= $uri->opaque;
	    $text=~ tr/_/ /;
	    ("["
	     . squarebracked_escape ($text.$fragmenttext)
	     . "](//"
	     . parens_uri_escape($uri->path).".md"
	     . do {
		 my $f= $uri->fragment;
		 length $f ? "#".parens_uri_escape($f) : ""
	     }
	     .")")
	} elsif (@parts==2) {
	    my ($loc,$text)= @parts;
	    "[".squarebracked_escape($text)."](".parens_uri_escape($loc).")"
	} else {
	    # XX location?...
	    die "more than 2 parts in a wiki style link: '$cont'";
	}
    %sge;
    $str
}

TEST { mediawiki_expand "<foo>[[bar]] baz</foo>" }
  '<foo>[bar](//bar.md) baz</foo>';

TEST { mediawiki_expand
	 ' [[howto#References (and "mutation"), "variables" versus "bindings"]] ' }
  ' [howto (References (and "mutation")..)](//howto.md#References%20%28and%20%22mutation%22%29,%20%22variables%22%20versus%20%22bindings%22) ';

TEST { mediawiki_expand ' [[Foo#yah\\[1\\]]] ' }
  ' [Foo (yah\\[1\\])](//Foo.md#yah[1]) ';

TEST { mediawiki_expand ' [[Foo#(yah)\\[1\\]|Some \\[text\\]]] ' }
  ' [Some \\[text\\]](Foo#%28yah%29[1]) '; # note: no // and .md added to Foo!


fun author_date ($path) {
    my $c= Chj::IO::Command->new_sender
      (sub {
	   xchdir $inbase;
	   xexec "git", "log", '--pretty=format:%aD', "--", $path
       });
    my $res= $c->xreadline;
    $c->xfinish;
    defined $res
      or die "can't get author date from file (not committed): '$path'";
    chomp $res; $res;
}

fun path0 ($path) {
    ## ugly way to strip path prefix
    my $path0= $path;
    while ($path0=~ s|^\.\./||){}; die if $path0=~ /\.\./;
    $path0
}

fun is_allcaps ($str) {
    not $str=~ /[a-z]/
}

# a path-append that doesn't output leading './'
fun path_path0_append ($dir,$relpath0) {
    my $p= "$dir/$relpath0";
    $p=~ s|^\./||;
    $p
}

fun if_suffix_md_to_html ($path0,$for_title,$then,$otherwise) {
    if (!$for_title and $$config{is_indexpath0}->($path0)) {
	tail &$then (path_path0_append (dirname($path0), "index.xhtml"))
    } else {
	if ($path0=~ s/(.*?)([^\/]*)\.md$/$1$2.xhtml/) {
	    tail &$then
	      ($$config{downcaps} && is_allcaps ($2) ? $1.lc($2).".xhtml"
	       : $path0);
	} else {
	    tail &$otherwise($path0)
	}
    }
}

fun t_if_suffix_md_to_html ($in,$for_title=0) {
    if_suffix_md_to_html ($in, $for_title,
		       sub {["then",@_]},
		       sub{["otherwise",@_]})
}
TEST{t_if_suffix_md_to_html "README.md"}['then','index.xhtml'];
TEST{t_if_suffix_md_to_html "README.md",1}['then','readme.xhtml'];
# ^ kinda stupid hack.
TEST{t_if_suffix_md_to_html "Foo/index.md"}['then','Foo/index.xhtml'];
TEST{t_if_suffix_md_to_html "Foo/README.md"}['then','Foo/index.xhtml'];
TEST{t_if_suffix_md_to_html "Foo/READMe.md"}['then','Foo/index.xhtml'];
# ^ XX really?
TEST{t_if_suffix_md_to_html "Foo/MY.css"}['otherwise','Foo/MY.css'];


fun possibly_suffix_md_to_html ($path,$for_title=0) {
    if_suffix_md_to_html
      ($path,
       $for_title,
       *identity,
       *identity)
}

fun xsuffix_md_to_html ($path0,$for_title) {
    if_suffix_md_to_html($path0, $for_title,
		      *identity,
		      sub{die "file does not end in .md: '$path0'"})
}

TEST{ possibly_suffix_md_to_html "foo" } "foo";
TEST{ possibly_suffix_md_to_html "foo.md" } "foo.xhtml";
TEST_EXCEPTION{ xsuffix_md_to_html "foo", 0 } "file does not end in .md: 'foo'";


fun path0_to_inpath ($path0) {
    "$inbase/".$path0
}

fun path0_to_outpath ($path0) {
    #"$outbase/".xsuffix_md_to_html($path0,0)
    # nope, also used for .pl file copying,
    "$outbase/".possibly_suffix_md_to_html($path0,0)
}

use HTML::TreeBuilder;
fun htmlparse_raw ($htmlstr,$whichtag) {
    my $t= HTML::TreeBuilder->new;
    $t->ignore_unknown(0); # allow <with_toc> elements
    $t->parse_content ($htmlstr);
    my $e= $t->elementify;
    # (^ actually mutates $t into the HTML::Element object already, ugh)
    $e->find_by_tag_name($whichtag)
}

use URI;

# avoid monkey-patching by prefixing instead
method URI_is_internal () {
    not defined $self->scheme
}


# fix internal links, add anchors, .. in generated HTML, as well as
# convert it to PXML.
fun htmlmap ($e,$selfpath0,$filesinfo) {
    my $name= lc($e->tag);
    my $atts={};
    for ($e->all_external_attr_names) {
	next if $_ eq "/";
	die "att name '$_'" unless /^\w+\z/s;
	$$atts{lc $_}= $e->attr($_);
    }

    # fix internal .md links
    if ($name eq "a"
	and URI_is_internal(my $uri= URI->new($$atts{href}))) {

	# check or find target, then convert to xhtml suffix
	my $path= $uri->path;

	# '//' feature (see doc-formatting.txt)
	if ($$atts{href} =~ m|^//|s) {
	    my ($op)= $uri->opaque() =~ m|^//([^/]+)$|s
	      or die "bug";
	    if (my ($p0)= $filesinfo->perhaps_filename_to_path0($op)) {
		$path= url_diff ($selfpath0,$p0); # mutation
	    } else {
		warn "unknown link target '$op' (from '$$atts{href}')";
		$path= url_diff ($selfpath0, "UNKNOWN/$op");
	    }
	    $uri->opaque(""); # mutation
	} else {
	    if (length $path) {
		my $p0= url_add(dirname ($selfpath0), $path);
		$p0=~ s|^\./||;#hack. grr y
		if ($filesinfo->all_path0_exists($p0)) {
		    $filesinfo->all_path0_used_inc($p0);
		} else {
		    warn "link target does not exist: '$p0' ".
		      "('$path' from '$selfpath0', link '$$atts{href}')";
		    #use Chj::repl;repl;
		}
	    }
	}
	if (length $path) {
	    $uri->path(possibly_suffix_md_to_html ($path));
	}
	$$atts{href}= "$uri";# mutation.
    }
    my $res= PXML::Element->new
	($name,
	 $atts,
	 [
	  map {
	      if (ref $_) {
		  # another HTML::Element
		  no warnings "recursion";# XX should rather sanitize input?
		  htmlmap ($_,$selfpath0,$filesinfo)
	      } else {
		  # a string
		  $_
	      }
	  } @{$e->content||[]}
	 ]);
    # add anchors
    if ($name =~ /^h(\d)$/) {
	my $text= $res->text;
	$text=~ s/ /_/sg;
	A({name=> $text}, $res)
    } else {
	$res
    }
}

# parse HTML string to PXML, fixing up stuff at the same time (through
# htmlmap)
fun htmlparse ($str,$whichtag,$selfpath0,$filesinfo) {
    htmlmap htmlparse_raw ($str,$whichtag), $selfpath0, $filesinfo
}


# Return <h1> element if available, and rest. HACKY: compensate for
# 'add anchors'. XX Stupid: should add anchors *afterwards* instead.
fun pxml_body_split_h1 ($body) {
    my $rec= fix fun ($rec, $b) {
	if (is_null $b) {
	    (undef, $body)
	} else {
	    my ($v,$rest)= $b->first_and_rest;
	    if (is_pxml_element $v
		and $v->name eq "a"
		and defined $v->maybe_attribute("name")) {
		my $v2;
		if (($v2)= stream_mixed_flatten($v->body)->perhaps_one
		    and is_pxml_element $v2
		    and $v2->name eq "h1") {
		    ($v2, $rest)
		} else {
		    (undef, $body)
		}
	    } else {
		(undef, $body)
	    }
	}
    };
    &$rec (stream_mixed_flatten $body)
}

TEST{ [pxml_body_split_h1 ["foo"]] }
  [ undef, ['foo']];

TEST{ [pxml_body_split_h1 [H1 ("x"), "foo"]]->[0] }
  undef; # because we *really* expect the A wrapper now. stupid, again

TEST{
    my ($h1,$rest)=
      pxml_body_split_h1 [A({name=>"x"}, H1 ("x", "y")), "foo", B "bar"];
    [ $h1->string, BODY($rest)->string ]
}
  ['<h1>xy</h1>', '<body>foo<b>bar</b></body>'];



#  the body


# builting a TOC = table of contents


fun rindices_numberstring ($rindices) {
    is_null $rindices ? "" :
      $rindices->reverse->map(fun($i){"$i."})->strings_join ("")." ";
}

TEST { rindices_numberstring (list ()) }     "";
TEST { rindices_numberstring (list (2,1)) }  "1.2. ";


{
    package PFLANZE::TocNodeBase;
    use FP::StrictList;
    use FP::Predicates;
    use FP::List;
    use PXML::XHTML ":all";

    use FP::Struct [[*is_strictlist, "subnodes"]];

    method subnodes_length () {
	$self->subnodes->length
    }

    method subnodes_add ($node) {
	is_instance_of $node, "PFLANZE::TocNode"
	  or die "wrong type";
	# (^ XX so poor, neither do I have a TypedList yet, nor the
	# syntax to add it to the method declaration)
	$self->subnodes_update(fun ($l){ cons $node, $l })
    }

    method subnodes_head_update ($fn) {
	my $ss= $self->subnodes;
	if (is_null $ss) {
	    die "skipped level" ## nicer message and all?
	} else {
	    $self->subnodes_set (cons (&$fn ($ss->first), $ss->rest))
	}
    }

    method level_add ($levelsdown, $node) {
	is_natural $levelsdown or die "wrong type: $levelsdown";
	if ($levelsdown > 1) {
	    $self->subnodes_head_update (fun ($subnode) {
		$subnode->level_add ($levelsdown - 1, $node)
	    })
	} else {
	    $self->subnodes_add ($node)
	}
    }

    # just for debugging? $indices is a list of 1-based indices
    method ref ($indices) {
	if (is_null $indices) {
	    $self
	} else {
	    my ($i,$indices1)= $indices->first_and_rest;
	    my $subnodes= $self->subnodes;
	    $subnodes->ref ($subnodes->length - $i)->ref ($indices1)
	}
    }

    # used during document mapping (while the toc is collected)
    method numberstring () {
	my $ss= $self->subnodes;
	my $len= $ss->length;
	# the first is the one that was added last
	$len ? $len . "." . $ss->first->numberstring
	  : "";
	# (O(n^2) complexity)
    }

    # build the TOC html. Need to get the numberstring differently
    # now.
    method html_with_parents ($rindices) {
	my $maybe_name= $self->name;
	my $shown= [main::rindices_numberstring ($rindices),
		    $self->header_pxml_for_toc ];
	DIR({class=> "toc"},
	    (defined $maybe_name ? A({href=> "#".$maybe_name}, $shown)
	     : $shown),
	    $self->subnodes->array__reverse__map_with_length
	    (fun ($node,$num) {
		LI ($node->html_with_parents(cons $num, $rindices))
	    }))
    }

    _END_
}

{
    package PFLANZE::TocNode;
    use FP::Predicates "is_string";
    use PXML "is_pxml_element";
    use FP::List;

    use FP::Struct [[*is_string, "name"], # as used in the <a name="">
                                          # already in the document
		    [*is_pxml_element, "header"]
		   ],
		     "PFLANZE::TocNodeBase";

    method header_pxml_for_toc () {
	# XX keep some formatting?
	$self->header->text
    }

    _END_
}

{
    package PFLANZE::TocRootNode;
    use FP::List;
    use PXML::XHTML ":all";

    use FP::Struct ["header_pxml_for_toc"], "PFLANZE::TocNodeBase";

    method name () { undef }

    method html () {
	DIV({class=> "toc_box"},
	    $self->html_with_parents (null))
    }

    _END__
}

our $empty_toc= PFLANZE::TocRootNode->new
  (strictnull,
   H3 ({class=> "toc_title"}, "Contents"));

sub tocnode ($$) {
    my ($name,$header)=@_;
    PFLANZE::TocNode->new(strictnull, $name, $header);
}

our $ttoc;
TEST {
    my $t1= $empty_toc->level_add (1, tocnode("a", H1("First")));
    my $t11= $t1->level_add (2, tocnode("b", H2("Sub-First")));
    my $t2= $t11->level_add (1, tocnode("c", H1("Second")));
    $ttoc= $t2;
    [ map { $_->numberstring } $t11, $t2 ]
}
  ['1.1.', '2.'];

TEST {
    my $t_paths= list (list(1), list(2), list(1,1));
    $t_paths->map (fun ($path) { $ttoc->ref ($path)-> name }) ->array }
  [qw(a c b)];

TEST { $ttoc->html->string }
  '<div class="toc_box">'
  .'<dir class="toc"><h3 class="toc_title">Contents</h3>'
  .  '<li><dir class="toc"><a href="#a">1. First</a>'
  .    '<li><dir class="toc"><a href="#b">1.1. Sub-First</a></dir></li>'
  .  '</dir></li>'
  .  '<li><dir class="toc"><a href="#c">2. Second</a></dir></li>'
  .'</dir></div>';


fun process__with_toc__body ($body, $first_level, $toc, $parents) {
    # -> (processed_body, toc)
    stream_mixed_state_fold_right
      (
       fun ($v,$toc,$rest) {
	   if (is_pxml_element ($v)) {
	       if (my ($_level)= $v->name =~ /^[hH](\d+)$/s) {
		   my $level= $_level - $first_level + 1;
		   is_natural $level
		     or die "The given <with_toc> tag dictates that the ".
		       "top-most header level is '$first_level', but ".
			 "encountering <".$v->name.">";

		   my $anchor= $parents->find (fun ($e) {
		       $e->name eq "a" and $e->maybe_attribute("name")
		   }) // die "bug, missing anchor element";

		   my $toc= $toc->level_add
		     ($level,
		      tocnode ($anchor->maybe_attribute("name"), $v));

		   my ($tail, $toc2)= &$rest ($toc);

		   (cons ($v->body_update
			  (fun ($body)
			   { cons ($toc->numberstring." ", $body) }),
			  $tail),
		    $toc2)
	       } else {
		   # map $v's body
		   my ($body2, $toc2)= process__with_toc__body
		     ($v->body, $first_level, $toc,
		      cons ($v, $parents));

		   my ($tail, $toc3)= &$rest ($toc2);

		   (cons ($v->body_set ($body2), $tail),
		    $toc3)
	       }
	   } else {
	       my ($tail, $toc2)= &$rest ($toc);
	       (cons ($v, $tail), $toc2)
	   }
       },
       fun ($toc) {
	   # return counter back up the chain
	   (null, $toc)
       },
       $body)->($toc);
}

TEST {
    my ($body,$toc)= process__with_toc__body (["foo"], 1, $empty_toc, null);
    [ $body->string, $toc->html->string ]
}
  [
   'foo',
   '<div class="toc_box"><dir class="toc"><h3 class="toc_title">Contents</h3></dir></div>'
  ];

TEST {HTML((process__with_toc__body
	    ["foo", A({name=>"a"}, H1("hed")),"bar"],
	    1,
	    $empty_toc, null)[0])->string}
  '<html>foo<a name="a"><h1>1. hed</h1></a>bar</html>';

TEST {HTML((process__with_toc__body
	    ["foo", A({name=>"a"}, H1("hed")),P("bar")],
	    1,
	    $empty_toc, null)[0])->string}
  '<html>foo<a name="a"><h1>1. hed</h1></a><p>bar</p></html>';

TEST {HTML((process__with_toc__body
	    [cons "foo", [A({name=>"a"}, H1("hed")),
			  A({name=>"b"}, H2("hud")),
			  ["",P("bar")]]],
	    1,
	    $empty_toc, null)[0])->string}
  '<html>foo<a name="a"><h1>1. hed</h1></a><a name="b"><h2>1.1. hud</h2></a><p>bar</p></html>';

TEST {HTML ((process__with_toc__body
	     [" ", P ("blabla"), A({name=>"a"}, H1 ("for one"))],
	     1,
	     $empty_toc, null)
	    [0])->string}
  '<html> <p>blabla</p><a name="a"><h1>1. for one</h1></a></html>';

# map <with_toc> element
fun with_toc ($e, $uplist) {
    my ($body, $toc)=
      process__with_toc__body ($e->body,
			       $e->maybe_attribute("level") // 2,
			       $empty_toc, null);
    [ $toc->html, $body]
}


# things that *do* exist as modules on CPAN but which we do not want
# to link since those are a different thing.
our $ignore_module_name= +{map {$_=>1}
			   qw(map tail grep)};
fun ignore_module_name ($name) {
    $$ignore_module_name{$name}
}

our $maybe_have_path0; # returns argument if we have it, undef otherwise
our $current_path0; # XX yes, messy, really add as lexical argument
                    # everywhere?

# add links to '`Foo::Bar`'
fun map_code ($e, $uplist) {
    my $t= $e->text;
    if (is_class_name ($t)) {
	my $module_subpath= $t;
	$module_subpath=~ s/::/\//sg;
	$module_subpath.=".pm";

	my $maybe_path=
	  (&$maybe_have_path0("lib/$module_subpath")
	   //
	   &$maybe_have_path0("meta/$module_subpath"));

	my $wrap_with_link= sub {
	    my ($url)=@_;
	    A {href=> $url}, $e
	};
	if (defined $maybe_path) {
	    &$wrap_with_link (url_diff $current_path0, $maybe_path)
	} elsif (ignore_module_name $t) {
	    $e
	} elsif (my $url= maybe_module_pod_url ($t)) {
	    &$wrap_with_link ($url)
	} else {
	    $e
	}
    } else {
	$e
    }
}


our $pxml_name_to_mapper=
  +{
    with_toc=> \&with_toc,
    code=> \&map_code,
   };

fun process_body ($v) {
    pxml_map_elements ($v, $pxml_name_to_mapper)
}

TEST { HTML( process_body
	     (["Hello",
	       WITH_TOC({level=>1},
			A({name=>"wo"}, H1 "world"))]))
	 ->string }
  '<html>Hello<div class="toc_box"><dir class="toc"><h3 class="toc_title">Contents</h3><li><dir class="toc"><a href="#wo">1. world</a></dir></li></dir></div><a name="wo"><h1>1. world</h1></a></html>';

TEST { HTML( process_body
	     (["Hello", WITH_TOC ["some", A {name=>"a"}, H2 "world"]]))
	 ->string }
  '<html>Hello<div class="toc_box"><dir class="toc"><h3 class="toc_title">Contents</h3><li><dir class="toc"><a href="#a">1. world</a></dir></li></dir></div>some<a name="a"><h2>1. world</h2></a></html>';

TEST { HTML( process_body  ([P("Hello"),
			     WITH_TOC
			     {level=>1},
			     [" ",
			      P ("blabla"),
			      A({name=>"a"}," ",DIV H1 ("for one")),
			     ]]))->string }
  '<html><p>Hello</p><div class="toc_box"><dir class="toc"><h3 class="toc_title">Contents</h3><li><dir class="toc"><a href="#a">1. for one</a></dir></li></dir></div> <p>blabla</p><a name="a"> <div><h1>1. for one</h1></div></a></html>';

TEST { HTML( process_body  ([P("Hello"),
			     WITH_TOC
			     {level=>1},
			     [" ",
			      P ("blabla"),
			      A({name=>"a"}, H1 ("for one")),
			      A({name=>"b"}, H2 ("more one")),
			      TABLE(TR
				    TD
				    P ("blah"),
				    A ({name=>"c"}, H1 ("sub two")),
				    DIV ("bla")),
			     ]]))->string }
  '<html><p>Hello</p>'.
  '<div class="toc_box"><dir class="toc"><h3 class="toc_title">Contents</h3><li><dir class="toc"><a href="#a">1. for one</a><li><dir class="toc"><a href="#b">1.1. more one</a></dir></li></dir></li><li><dir class="toc"><a href="#c">2. sub two</a></dir></li></dir></div>'.
  ' <p>blabla</p><a name="a"><h1>1. for one</h1></a><a name="b"><h2>1.1. more one</h2></a><table><tr><td><p>blah</p><a name="c"><h1>2. sub two</h1></a><div>bla</div></td></tr></table></html>';


use PXML::Serialize 'pxml_xhtml_print_fast';

# v- is now in PXML::Serialize, too, except for the xmkdir_p
fun puthtmlfile ($path,$p) {
    xmkdir_p dirname $path;
    my $out= xopen_write($path);
    binmode $out, ":utf8" or die;
    pxml_xhtml_print_fast($p, $out, "en");# hard coded lang
    $out->xclose;
}



{
    package PFLANZE::Filesinfo;
    use FP::Hash "hash_perhaps_ref";
    use FP::Struct [qw(files
			filename_to_path0
			all_path0_exists
			path0_exists
			all_path0_used
		      )];
    method filename_to_path0 ($filename) {
	$$self{filename_to_path0}{$filename}
	  // die "no mapping for filename '$filename'"
    }
    method filename_to_maybe_path0 ($filename) {
	$$self{filename_to_path0}{$filename}
    }
    # still very unclear about the exact name styling. Prefer perhaps,
    # and "then" also move the qualificator to the front? (but leave
    # the one for hash_ where it is since hash_ is the type prefix?) :
    method perhaps_filename_to_path0 ($filename) {
	hash_perhaps_ref ($$self{filename_to_path0}, $filename)
    }
    method all_path0_exists ($path0) {
	defined $$self{all_path0_exists}{$path0}
	  or
	defined $$self{all_path0_exists}{$path0."/"}
    }
    method path0_is_directory ($path0) {
	$path0=~ s|/+$||s;
	defined $$self{all_path0_exists}{$path0."/"}
    }
    method path0_exists ($path0) {
	defined $$self{path0_exists}{$path0}
    }
    method all_path0_used_inc ($path0) {
	$$self{all_path0_used}{$path0}++
    }
    _END_
}

fun get_filesinfo () {
    my $c= Chj::IO::Command->new_sender
      (sub {
	   xchdir $inbase;
	   xexec "git","ls-files","-z"
       });
    my $all_files= [$c->xreadline0chop];
    $c->xxfinish;

    my $files= [grep {
	/\.md$/
    } @$all_files];

    my $filename_to_path0=
      +{map {
	  basename ($_)=> path0($_)
      } @$files};

    my $all_path0_exists=
      +{
	map {
	    path0($_)=>1
	}
	@$all_files,
	# and their directories, ok? Any directory that has files
	# from git will be ok as link target, ok?
	map {
	    dirname($_)."/"
	}
	@$all_files
       };

    my $path0_exists=
      +{map {
	  path0($_)=>1
      } @$files};

    my $all_path0_used= {};

    PFLANZE::Filesinfo->new($files,
			$filename_to_path0,
			$all_path0_exists,
			$path0_exists,
			$all_path0_used)
}


our $path0_to_sortkey= do {
    my $sortprio= do {
	my $i=1;
	+{
	  map {
	      my $file= $_;
	      $file.= ".md" unless /\.\w{1,7}\z/;
	      $file=> sprintf('-%04d', $i++)
	  } @{$config->{sortorder} || []}
	 }
    };
    fun ($path0) {
	$$sortprio{$path0} || $path0
    }
};

fun _path0_to_title_mod ($str) {
    $str=~ s/_/ /sg;
    ucfirst $str
}

fun path0_to_title ($path0) {
    my $dn= dirname($path0);
    if ($dn ne "." and $$config{is_indexpath0}->($path0)) {
	_path0_to_title_mod
	  basename ( xsuffix_md_to_html($dn.".md",1), ".xhtml");
    } else {
	_path0_to_title_mod
	  basename( xsuffix_md_to_html ($path0,1),".xhtml");
    }
}

TEST{path0_to_title "README.md"} 'Readme';
TEST{path0_to_title "bugs/wishlist/listserv/index.md"} 'Listserv';
TEST{path0_to_title "bugs/wishlist/listserv/README.md"} 'Listserv';
TEST{path0_to_title "bugs/wishlist/listserv/other.md"} 'Other';
use FP::Predicates 'false';
TEST{
    local $config= +{is_indexpath0=> *false};
    path0_to_title "bugs/wishlist/listserv/README.md"
}
  'README'; # XXX why?, expected: 'Readme';
TEST{path0_to_title "bugs/wishlist/line_wrapping_in_pre-MIME_mails.md"}
  # even with lcfirst
  'Line wrapping in pre-MIME mails';


fun path0_to_bugtype ($path0) {
    $path0=~ m|\bbugs/([^/]+)/| or die "no match, '$path0'";
    ucfirst $1
}

{
    package PFLANZE::Cost;
    use FP::Array ":all";
    use FP::Struct [qw(name is_purchaseable basecosts val)];
    method cost ($index) {
	$$self{_cost} ||= do {
	    add($self->val,
		map {
		    $$index{$_}->cost ($index)
		} @{$self->basecosts}
	       );
	}
    }
    _END_
}
{
    package PFLANZE::Totalcost;
    use FP::Array_sort ":all";
    use FP::Struct [qw(costs)];
    method range () {
	@{$$self{costs}} or die "no costs given";#
	my $index;
	for (@{$$self{costs}}) {
	    if (defined (my $name= $_->name)) {
		$$index{$name}= $_
	    }
	}
	my $purchaseable= [grep { $_->is_purchaseable } @{$$self{costs}}];
	@$purchaseable or die "no purchaseable costs";#
	local our $all= array_sort
	  ( $purchaseable,
	    on the_method ("cost",$index), \&number_cmp );
	(@$all == 1
	 ? $$all[0]->cost ($index)
	 : $$all[0]->cost ($index)."..".$$all[-1]->cost($index)),
    }
    _END_
}


# group $files, to process them in an order that satisfies dependency
# on $costranges

fun groupkey ($path) {
    my $p0= path0 $path;
    if ($p0=~ m|^bugs/|) {
	"bugs"
    } elsif ($p0 =~ m|^docs/bugs.*\.md$|) {
	"buglist"
    } else {
	"normal"
    }
}


{
    package PFLANZE::Genfilestate;
    use FP::Struct [qw(filesinfo
			groupedfiles
			nonbugfiles
			costranges)];
    # ugly to keep that costranges state here ? well call it Genfilestate then?
    method set_costrange ($path0,$maybe_costrange) {
	$$self{costranges}{$path0}= $maybe_costrange;
    }
    method costrange ($path0) {
	$$self{costranges}{$path0}
    }
    _END_
}

fun get_genfilestate ($filesinfo) {
    my $groupedfiles= array_to_hash_group_by $filesinfo->files, \&groupkey;

    my $nonbugfiles= [@{$$groupedfiles{normal}},
		      @{$$groupedfiles{buglist}||[]}];

    my $costranges={};
    # path0 -> costrange-string; filled when processing non-buglist groups

    PFLANZE::Genfilestate->new
	($filesinfo, # just so as to bundle it up, too, ugly?
	 $groupedfiles,
	 $nonbugfiles,
	 $costranges)
}

fun genfile ($path,$groupname,$genfilestate) {
    my $path0= path0 $path;
    my $outpath= path0_to_outpath($path0);
    mkdir dirname( $outpath);

    my $filetitle= path0_to_title $path0;

    my $str= xgetfile_utf8 "$inbase/$path";

    if ($$config{warn_hint}) {
	$str=~ s/^\(Check the.*?website.*?---\s+//s
	  or $path=~/COPYING|bugs\// or warn "'$path' is missing hint";
    }

    if (my $hdl= $config->{path0_handlers}->{$path0}) {
	$str= $hdl->($path,$path0,$str);
    }

    my $maybe_costrange= do {
	# extract Cost indicators:
	my $namere= qr/\w+/;
	my $nameplusre= qr/\(?$namere\)?/;
	my $possibly_nameplus_to_name= fun ($maybe_nameplus) {
	    if (defined $maybe_nameplus) {
		my ($name)= $maybe_nameplus=~ qr/($namere)/
		  or die "bug";
		$name
	    } else {
		undef
	    }
	};
	local our $costs=[];
	while (#my ($name,$basecosts,$val)=
	       $str=~ m{\b[Cc]ost
			# name: parentheses for "library cost"
			(?:\s+($nameplusre))?
			:
			\s*
			# base costs
			((?:$nameplusre\s*\+\s*)*)
			\s*
			# amount
			\$\s*(\d+)
		   }gx) {
	    my ($nameplus,$basecosts,$val)=($1,$2,$3);# perl.
	    my $name= &$possibly_nameplus_to_name($nameplus);
	    my @basecosts= map { &$possibly_nameplus_to_name($_) }
	      split /\s*\+\s*/, $basecosts;
	    push @$costs, new PFLANZE::Cost ($name,
					 (not $nameplus
					  or not($nameplus=~ /^\(/)),
					 \@basecosts,
					 $val);
	}
	#local our $totalcost=
	#  PFLANZE::Totalcost->new($costs);
	#use Chj::Backtrace; use Chj::repl;repl if @$costs;#exit;
	@$costs ? PFLANZE::Totalcost->new($costs)->range : undef
    };
    if (defined $maybe_costrange) {
	$genfilestate->set_costrange($path0, $maybe_costrange);
    }

    my $htmlstr= markdown (mediawiki_expand $str);

    # XX hack: fix '<p><with_toc></p> .. <p></with_toc></p>' before
    # parsing, to avoid losing the with_toc element. Bah.
    $htmlstr=~ s|<p>\s*(</?with_toc[^<>]*>)\s*</p>|$1|sg;

    my $body= htmlparse($htmlstr, "body", $path0,
			$genfilestate->filesinfo);

    my ($h1,$body1)= do {
	my $body= $body->body;
	my ($maybe_h1, $rest)= pxml_body_split_h1 ($body);
	defined $maybe_h1 ? ($maybe_h1, $rest)
	  : (H1(path0_to_title ($path0)), $body);
    };

    my $maybe_buglist= $groupname eq "buglist" && do {
	my $bugs=
	  array_sort
	    (array_map
	     (
	      fun ($path) {
		  my $path0= path0 $path;
		  my $title= path0_to_title $path0;
		  [$title,$path0,$genfilestate->costrange($path0)]
	      },
	      $genfilestate->groupedfiles->{bugs}),
	     on sub{$_[0][0]}, \&string_cmp # XX not a good cmp.
	    );

	TABLE
	  ({class=> "costlist"},
	   THEAD (TH ("Type"), TH ("Title"),TH ("Cost range (USD)")),
	   map {
	       my ($title,$p0,$costrange)= @$_;
	       my $relurl= File::Spec->abs2rel(xsuffix_md_to_html($p0,0),
					       basename ($path0));
	       TR (TD (path0_to_bugtype $p0),
		   TD (A({href=>$relurl},$title)),
		   TD ({align=>"center"},$costrange))
	   } @$bugs
	  )
    };

    # pass values to html mappers:  XX hacky?
    local $current_path0= $path0;
    my $filesinfo= $genfilestate->filesinfo;
    local $maybe_have_path0= fun ($path0) {
	if ($filesinfo->all_path0_exists ($path0)) {
	    $filesinfo->all_path0_used_inc($path0);
	    $path0
	} else {
	    undef
	}
    };

    my $html=
      HTML (
	    HEAD (
		  TITLE ($config->{title}->($filetitle)),
		  LINK ({rel=> "stylesheet",
			 href=> url_diff ($path0, $css_path),
			 type=> "text/css"}),
		  $config->{head}->($path0),
		 ),
	    BODY(
		 $config->{header}->($path0),
		 UL({class=> "menu"},
		    array_map_with_islast
		    (
		     fun ($is_last,$file0) {
			 my $filetitle= path0_to_title $file0;
			 LI({class=> ($is_last ? "menu_last"
				      : "menu")},
			    ($file0 eq $path0 ?
			     SPAN({class=> "menu_selected"},
				  $filetitle)
			     : A ({class=> "menu",
				   href=>
				   File::Spec->abs2rel
				   (xsuffix_md_to_html($file0,0),
				    dirname($path0))},
				  $filetitle)),
			    " ")
		     },
		     array_sort
		     (array_map (\&path0,
				 $genfilestate->nonbugfiles),
		      on $path0_to_sortkey, \&string_cmp))),
		 $config->{belownav}->($path0),
		 $h1,
		 process_body ($body1),
		 $maybe_buglist,
		 BR,
		 HR,
		 ($maybe_costrange ? P("\x{21d2} Cost range: \$",
				       $maybe_costrange) : ()),
		 DIV({class=>"footer_date"}, author_date($path))));

    puthtmlfile($outpath, $html);
}


fun genfiles ($filesinfo) {
    my $genfilestate= get_genfilestate ($filesinfo);
    for my $groupname (qw(bugs normal buglist)) {
	for (@{$genfilestate->groupedfiles->{$groupname}}) {
	    genfile $_,$groupname,$genfilestate
	}
    }
}

# lib?
fun existingpath_or (@paths) {
    for (@paths) {
	return $_ if -e $_
    }
    die "none of the paths exist: @paths";
}


use POSIX qw(EEXIST ENOENT);

fun create_parent_dirs ($path0, $path0_to_outpath) {
    my $path0= dirname $path0;
    my $outpath= &$path0_to_outpath ($path0);
    if (mkdir $outpath) {
	# ok, return
    } elsif ($! == EEXIST) {
	# ok, return
    } elsif ($! == ENOENT) {
	create_parent_dirs ($path0, $path0_to_outpath);
	xmkdir $outpath;
    } else {
	die "mkdir '$outpath': $!";
    }
}

# copy referenced non-.md files:
fun copyfiles ($filesinfo) {
    for my $path0 (hashset_keys
		   hashset_union($filesinfo->all_path0_used,
				 array_to_hashset
				 (hash_ref_or ($config, "copy_paths", [])))) {
	next if $filesinfo->path0_exists($path0); # md path
	next if $filesinfo->path0_is_directory($path0);
	create_parent_dirs ($path0, \&path0_to_outpath);
	xcopyfile (path0_to_inpath($path0), path0_to_outpath($path0));
    }
    if (my ($separate)= hash_perhaps_ref($config, "copy_paths_separate")) {
	for my $root (keys %$separate) {
	    for my $path0 (@{$$separate{$root}}) {
		xcopyfile "$root/$path0", path0_to_outpath $path0
	    }
	}
    }
    # copy htmlgen CSS file
    xcopyfile (existingpath_or (path0_to_inpath($css_path),
				path0_to_inpath("htmlgen/$css_path")),
	       path0_to_outpath($css_path));
}

fun main () {
    my $filesinfo= get_filesinfo;
    genfiles ($filesinfo);
    copyfiles ($filesinfo);
}


perhaps_run_tests __PACKAGE__
  or do {
      if ($opt_trap) {
	  require Chj::WithRepl; &Chj::WithRepl::push_withrepl (0);
      }

      $opt_repl ? do {
	  require Chj::repl;
	  require Chj::WithRepl; &Chj::WithRepl::push_withrepl (0);
	  Chj::repl::repl();
      } : main;
};

