#!/usr/bin/env perl

use strict; use warnings; use warnings FATAL => 'uninitialized';

# Method::Signatures versions 20120523 and 20141021 are working badly
# for this file, because (1) each package needs its own import, (2)
# error locations are completely off. Thus, still use the trusty
# Function::Parameters.

use Function::Parameters qw(:strict);
use Sub::Call::Tail;
use Chj::Backtrace;

# find modules from functional-perl working directory (not installed)
use Cwd 'abs_path';
our ($mydir, $myname); BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/../lib";


our $css_path= "htmlgen.css";

sub usage {
    print "$myname config inbase outbase

  config is the path to a Perl file ending in a hash with config
  values, see gen-ml2json.pl for an example.

  inbase needs to be a git working directory.

  Assumes that there is a file '$css_path', which is included in the
  <head/> and copied to outbase.

";
    exit 1;
}

use Getopt::Long;
our $verbose=0;
our $opt_repl;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "repl"=> \$opt_repl,
	   ) or exit 1;
usage unless @ARGV==3 or ($opt_repl and @ARGV>=1);

our ($configpath, $inbase, $outbase)= @ARGV;

our $user_config= require $configpath;

mkdir $outbase;

use Hash::Util 'lock_hash';
use Text::Markdown 'markdown';
use Chj::IO::Command;
use Chj::xperlfunc ':all';
use Chj::xopen ":all";
use Chj::chompspace;
use Chj::xIOUtil qw(xputfile_utf8 xgetfile_utf8 xcopyfile);
use FP::HashSet ":all";
use PXML::XHTML ":all";
use FP::Array ":all";
use File::Spec;
use FP::Array_sort;
use FP::Ops qw(string_cmp number_cmp);
use Chj::TEST ":all";
use FP::List ":all";
use FP::Lazy ":all";
use FP::Stream ":all";
use PXML "is_pxml_element";
use PXML::Util ":all";
use FP::Hash ":all";
use FP::Div 'identity';
use PXML::Tags qw(with_toc);
use FP::fix;

our $default_config=
  +{
    indexpath0P => fun ($path0) {
	my $bn= lc basename($path0);
	$bn eq "index.md" or $bn eq "readme.md"
    },
   };


our $config = hashset_union ($user_config, $default_config);

lock_hash %$config;

# operating on markdown source string
# XX should this replace the document name with the document title?
fun mediawiki_expand ($str) {
    $str=~ s%(?<=[^\\])\[\[(.*?[^\\])\]\]%
	my $cont= $1;
	my @parts= map { chompspace $_ } split /(?<=[^\\])\|/, $cont;
	if (@parts==1) {
	    my ($docname)= @parts;
	    # XX get title?
	    my $text= $docname;
	    $text=~ tr/_/ /;
	    "[$text](//${docname}.md)" # XX escape?
	} elsif (@parts==2) {
	    my ($loc,$text)= @parts;
	    "[$text]($loc)" # XX escape url?
	} else {
	    # XX location?...
	    die "more than 2 parts in a wiki style link: '$cont'";
	}
    %sge;
    $str
}

fun author_date ($path) {
    my $c= Chj::IO::Command->new_sender
      (sub {
	   xchdir $inbase;
	   xexec "git", "log", '--pretty=format:%aD', "--", $path
       });
    my $res= $c->xreadline;
    $c->xfinish;
    chomp $res; $res;
}

fun path0 ($path) {
    ## ugly way to strip path prefix
    my $path0= $path;
    while ($path0=~ s|^\.\./||){}; die if $path0=~ /\.\./;
    $path0
}

fun is_allcaps ($str) {
    not $str=~ /[a-z]/
}

# a path-append that doesn't output leading './'
fun path_path0_append ($dir,$relpath0) {
    my $p= "$dir/$relpath0";
    $p=~ s|^\./||;
    $p
}

fun if_suffix_md2html ($path0,$for_title,$then,$otherwise) {
    if (!$for_title and $$config{indexpath0P}->($path0)) {
	tail &$then (path_path0_append (dirname($path0), "index.xhtml"))
    } else {
	if ($path0=~ s/(.*?)([^\/]*)\.md$/$1$2.xhtml/) {
	    tail &$then
	      ($$config{downcaps} && is_allcaps ($2) ? $1.lc($2).".xhtml" : $path0);
	} else {
	    tail &$otherwise($path0)
	}
    }
}

fun t_if_suffix_md2html ($in,$for_title=0) {
    if_suffix_md2html $in, $for_title, sub {["then",@_]}, sub{["otherwise",@_]}
}
TEST{t_if_suffix_md2html "README.md"}['then','index.xhtml'];
TEST{t_if_suffix_md2html "README.md",1}['then','readme.xhtml']; # kinda stupid hack.
TEST{t_if_suffix_md2html "Foo/index.md"}['then','Foo/index.xhtml'];
TEST{t_if_suffix_md2html "Foo/README.md"}['then','Foo/index.xhtml'];
TEST{t_if_suffix_md2html "Foo/READMe.md"}['then','Foo/index.xhtml']; # XX really?
TEST{t_if_suffix_md2html "Foo/MY.css"}['otherwise','Foo/MY.css'];


fun perhaps_suffix_md2html ($path,$for_title=0) {
    if_suffix_md2html
      ($path,
       $for_title,
       fun ($path) { $path },
       fun ($path) { $path }
      )
}

fun xsuffix_md2html ($path0,$for_title) {
    if_suffix_md2html($path0, $for_title, sub{$_[0]}, sub{die})
}

fun path02inpath ($path0) {
    "$inbase/".$path0
}

fun path02outpath ($path0) {
    #"$outbase/".xsuffix_md2html($path0,0)
    # nope, also used for .pl file copying,
    "$outbase/".perhaps_suffix_md2html($path0,0)
}

use HTML::TreeBuilder;
fun htmlparse_raw ($htmlstr,$whichtag) {
    warn "HTMLPARSE_RAW htmlstr: $htmlstr";
    my $t= HTML::TreeBuilder->new;
    $t->ignore_unknown(0); # allow <with_toc> elements
    $t->parse_content ($htmlstr);
    my $e= $t->elementify;
    # (^ actually mutates $t into the HTML::Element object already, ugh)
    $e->find_by_tag_name($whichtag)
}

use URI;
fun url_is_internal ($str) {
    my $u= URI->new($str);
    not defined $u->scheme
}


# fix internal links, add anchors, .. in generated HTML, as well as
# convert it to PXML.
fun htmlmap ($e,$selfpath0,$filesinfo) {
    my $name= lc($e->tag);
    my $atts=();
    for ($e->all_external_attr_names) {
	next if $_ eq "/";
	die "att name '$_'" unless /^\w+\z/s;
	$$atts{lc $_}= $e->attr($_);
    }
    # fix internal .md links
    if ($name eq "a"
	and url_is_internal($$atts{href})) {

	# check or find target, then convert to xhtml suffix
	my $uri= URI->new($$atts{href}); #(h again,see url_is_internal..)
	my $path= $uri->path;

	# '//' feature (see doc-formatting.txt)
	if ($$atts{href} =~ m|^//|s) {
	    my ($op)= $uri->opaque() =~ m|^//([^/]+)$|s
	      or die "bug";
	    if (defined (my $p0= $filesinfo->filename2path0($op))) {
		$path= url_diff ($selfpath0,$p0); # mutation
	    } else {
		die "unknown link target '$op' (from '$$atts{href}')";
	    }
	    $uri->opaque(""); # mutation
	} else {
	    if (length $path) {
		my $p0= url_add(dirname ($selfpath0), $path);
		$p0=~ s|^\./||;#hack. grr y
		if ($filesinfo->all_path0_exists($p0)) {
		    $filesinfo->all_path0_used_inc($p0);
		} else {
		    warn "link target does not exist: '$p0' ('$path' from '$selfpath0', link '$$atts{href}')";
		    #use Chj::repl;repl;
		}
	    }
	}
	$path= perhaps_suffix_md2html ($path);
	$uri->path($path);
	$$atts{href}= "$uri";# mutation.
    }
    my $res= PXML::Element->new
	($name,
	 $atts,
	 [
	  map {
	      if (ref $_) {
		  # another HTML::Element
		  no warnings "recursion";# XX should rather sanitize input?
		  htmlmap ($_,$selfpath0,$filesinfo)
	      } else {
		  # a string
		  $_
	      }
	  } @{$e->content||[]}
	 ]);
    # add anchors
    if ($name =~ /^h(\d)$/) {
	my $text= $res->text;
	$text=~ s/ /_/sg;
	A({name=> $text}, $res)
    } else {
	$res
    }
}

# parse HTML string to PXML, fixing up stuff at the same time (through
# htmlmap)
fun htmlparse ($str,$whichtag,$selfpath0,$filesinfo) {
    htmlmap htmlparse_raw ($str,$whichtag), $selfpath0, $filesinfo
}


# Return <h1> element if available, and rest. HACKY: compensate for
# 'add anchors'. XX Stupid: should add anchors *afterwards* instead.
fun pxml_body_split_h1 ($body) {
    my $rec= fix fun ($rec, $b) {
	if (is_null $b) {
	    (undef, $body)
	} else {
	    my ($v,$rest)= $b->first_and_rest;
	    if (is_pxml_element $v
		and $v->name eq "a"
		and defined $v->maybe_attribute("name")) {
		my $v2;
		if (($v2)= stream_mixed_flatten($v->body)->perhaps_one
		    and is_pxml_element $v2
		    and $v2->name eq "h1") {
		    ($v2, $rest)
		} else {
		    (undef, $body)
		}
	    } else {
		(undef, $body)
	    }
	}
    };
    &$rec (stream_mixed_flatten $body)
}

TEST{ [pxml_body_split_h1 ["foo"]] }
  [ undef, ['foo']];

TEST{ [pxml_body_split_h1 [H1 ("x"), "foo"]]->[0] }
  undef; # because we *really* expect the A wrapper now. stupid, again

TEST{
    my ($h1,$rest)=
      pxml_body_split_h1 [A({name=>"x"}, H1 ("x", "y")), "foo", B "bar"];
    [ $h1->string, BODY($rest)->string ]
}
  ['<h1>xy</h1>', '<body>foo<b>bar</b></body>'];



#  the body

{
    package PFLANZE::TocCounter;
    use base 'FP::PureArray';
    use FP::Predicates;
    use Chj::NamespaceCleanAbove;

    sub inc {
	my ($s,$level)=@_;
	is_natural $level or die "invalid level: $level";
	$s->sub (0,$level)
	  ->update ($level-1, sub {
			my $v= $_[0] // 0;
			$v + 1
		    });
    }

    sub string {
	my $s=shift;
	my @l= @$s;
	shift @l while @l and not defined $l[0];
	join ".", map { ($_//0) } @l;
    }

    sub level {
	my $s=shift;
	scalar @$s
    }

    _END_
}

our $empty_toccounter= PFLANZE::TocCounter->empty;

TEST {
    use FP::Array ":all"; use FP::Ops "the_method";
    my $c;
    my $s1= $c= $empty_toccounter->inc (1);
    my $s1_1= $c= $c->inc (2);
    my $s1_2= $c= $c->inc (2);
    my $s2= $c= $c->inc (1);
    #array_map the_method ("string"), [$s1, $s1_1, $s1_2, $s2]
    #[$s1, $s1_1, $s1_2, $s2]->map(the_method "string")
    #list($s1, $s1_1, $s1_2, $s2)->map(the_method "string")
    #[map { $_->string } $s1, $s1_1, $s1_2, $s2]
    #(map .string (list s1 s1_1 s1_2 s2))
    # so much for rich syntax (incl. fingernail clippings)
    [map { [$_->string, $_->level] } $s1, $s1_1, $s1_2, $s2]
}
  [["1",1], ["1.1",2], ["1.2",2], ["2",1]];


fun process_with_toc_body ($body, $counter) {
    # -> (processed_body, incremented_counter)
    stream_mixed_state_fold
      (
       fun ($v,$counter,$rest) {
	   if (is_pxml_element ($v)) {
	       if (my ($level)= $v->name =~ /^[hH](\d+)$/s) {
		   my $counter= $counter->inc($level);
		   my ($tail, $counter2)= &$rest ($counter);
		   (cons ($v->body_update
			  (fun ($body)
			   { cons ($counter->string.". ", $body) }),
			  $tail),
		    $counter2)
	       } else {
		   # map $v's body
		   my ($body2, $counter2)= process_with_toc_body
		     ($v->body,$counter);
		   my ($tail, $counter3)= &$rest ($counter2);
		   (cons ($v->body_set ($body2), $tail),
		    $counter3)
	       }
	   } else {
	       my ($tail, $counter2)= &$rest ($counter);
	       (cons ($v, $tail), $counter2)
	   }
       },
       fun ($counter) {
	   # return counter back up the chain
	   (null, $counter)
       },
       $body)->($counter);
}

TEST {[map {$_->string}
       process_with_toc_body ["foo"], $empty_toccounter ]}
  [
   'foo',
   ''
  ];

TEST {HTML((process_with_toc_body ["foo",H1("hed"),"bar"],
	    $empty_toccounter)[0])->string}
  '<html>foo<h1>1 hed</h1>bar</html>';

TEST {HTML((process_with_toc_body ["foo",H1("hed"),P("bar")],
	    $empty_toccounter)[0])->string}
  '<html>foo<h1>1 hed</h1><p>bar</p></html>';

TEST {HTML((process_with_toc_body [cons "foo",[H1("hed"),H2("hud"),["",P("bar")]]],
	    $empty_toccounter)[0])->string}
  '<html>foo<h1>1 hed</h1><h2>1.1 hud</h2><p>bar</p></html>';

TEST {HTML ((process_with_toc_body [" ", P ("blabla"), H1 ("for one")],
	     $empty_toccounter)
	    [0])->string}
  '<html> <p>blabla</p><h1>1 for one</h1></html>';

# map <with_toc> element
fun with_toc ($e, $uplist) {
    warn "with_toc";
    (process_with_toc_body ($e->body, $empty_toccounter))[0]
}

fun pxml_map_elements ($v, $name2mapper) {
    pxml_eager_map ($v,
		    fun ($e, $uplist) {
			if (my ($mapper)= hash_ref $name2mapper, $e->name) {
			    &$mapper ($e, $uplist)
			} else {
			    $e
			}
		    },
		    undef);
}


our $pxml_name2mapper=
  +{
    with_toc=> \&with_toc,
   };

fun process_body ($v) {
    warn "BODY=".HTML ($v)->string;
    pxml_map_elements ($v, $pxml_name2mapper)
}

TEST { HTML( process_body  (["Hello", WITH_TOC H1 "world"]))->string }
  '<html>Hello<h1>1 world</h1></html>';

TEST { HTML( process_body  (["Hello", WITH_TOC ["some", H1 "world"]]))->string }
  '<html>Hellosome<h1>1 world</h1></html>';

TEST { HTML( process_body  ([P("Hello"),
			     WITH_TOC
			     [" ",
			      P ("blabla"),
			      H1 ("for one"),
			     ]]))->string }
  '<html><p>Hello</p> <p>blabla</p><h1>1 for one</h1></html>';

TEST { HTML( process_body  ([P("Hello"),
			     WITH_TOC
			     [" ",
			      P ("blabla"),
			      H1 ("for one"),
			      H2 ("more one"),
			      P ("blah"),
			      H1 ("sub two"),
			      DIV ("bla"),
			     ]]))->string }
  '<html><p>Hello</p> <p>blabla</p><h1>1 for one</h1><h2>1.1 more one</h2><p>blah</p><h1>2 sub two</h1><div>bla</div></html>';


use PXML::Serialize 'pxml_xhtml_print_fast';

# v- is now in PXML::Serialize, too, except for the xmkdir_p
fun puthtmlfile ($path,$p) {
    xmkdir_p dirname $path;
    my $out= xopen_write($path);
    binmode $out, ":utf8" or die;
    pxml_xhtml_print_fast($p, $out, "en");# hard coded lang
    $out->xclose;
}



{
    package PFLANZE::Filesinfo;
    use FP::Struct [qw(files
			filename2path0
			all_path0_exists
			path0_exists
			all_path0_used
		      )];
    method filename2path0 ($filename) {
	$$self{filename2path0}{$filename}
    }
    method all_path0_exists ($path0) {
	defined $$self{all_path0_exists}{$path0}
	  or
	defined $$self{all_path0_exists}{$path0."/"}
    }
    method path0_is_directory ($path0) {
	$path0=~ s|/+$||s;
	defined $$self{all_path0_exists}{$path0."/"}
    }
    method path0_exists ($path0) {
	defined $$self{path0_exists}{$path0}
    }
    method all_path0_used_inc ($path0) {
	$$self{all_path0_used}{$path0}++
    }
    _END_
}

fun get_filesinfo () {
    my $c= Chj::IO::Command->new_sender
      (sub {
	   xchdir $inbase;
	   xexec "git","ls-files","-z"
       });
    my $all_files= [$c->xreadline0chop];
    $c->xxfinish;

    my $files= [grep {
	/\.md$/
    } @$all_files];

    my $filename2path0=
      +{map {
	  basename ($_)=> path0($_)
      } @$files};

    my $all_path0_exists=
      +{
	map {
	    path0($_)=>1
	}
	@$all_files,
	# and their directories, ok? Any directory that has files
	# from git will be ok as link target, ok?
	map {
	    dirname($_)."/"
	}
	@$all_files
       };

    my $path0_exists=
      +{map {
	  path0($_)=>1
      } @$files};

    my $all_path0_used= {};

    PFLANZE::Filesinfo->new($files,
			$filename2path0,
			$all_path0_exists,
			$path0_exists,
			$all_path0_used)
}


our $path02sortkey= do {
    my $sortprio= do {
	my $i=1;
	+{
	  map {
	      my $file= $_;
	      $file.= ".md" unless /\.\w{1,7}\z/;
	      $file=> sprintf('-%04d', $i++)
	  } @{$config->{sortorder} || []}
	 }
    };
    fun ($path0) {
	$$sortprio{$path0} || $path0
    }
};

fun _path02title_mod ($str) {
    $str=~ s/_/ /sg;
    ucfirst $str
}

fun path02title ($path0) {
    my $dn= dirname($path0);
    if ($dn ne "." and $$config{indexpath0P}->($path0)) {
	_path02title_mod
	  basename ( xsuffix_md2html($dn.".md",1), ".xhtml");
    } else {
	_path02title_mod
	  basename( xsuffix_md2html ($path0,1),".xhtml");
    }
}

TEST{path02title "README.md"} 'Readme';
TEST{path02title "bugs/wishlist/listserv/index.md"} 'Listserv';
TEST{path02title "bugs/wishlist/listserv/README.md"} 'Listserv';
TEST{path02title "bugs/wishlist/listserv/other.md"} 'Other';
use FP::Predicates 'false';
TEST{
    local $config= +{indexpath0P=> *false};
    path02title "bugs/wishlist/listserv/README.md"
}
  'README'; # XXX why?, expected: 'Readme';
TEST{path02title "bugs/wishlist/line_wrapping_in_pre-MIME_mails.md"} # even with lcfirst
  'Line wrapping in pre-MIME mails';


fun path02bugtype ($path0) {
    $path0=~ m|\bbugs/([^/]+)/| or die "no match, '$path0'";
    ucfirst $1
}

# move to lib
use File::Spec;
use Chj::Path;
use Chj::TEST ":all";

fun url_add ($base,$rel) {
    Chj::Path->new_from_string($base)->add
	(Chj::Path->new_from_string($rel), 1)
	  ->string
}

TEST{url_add "/foo", "/zoo" } "/zoo";
TEST{url_add "/foo", "../zoo" } "/zoo";
TEST{url_add "/foo", "zoo/loo" } "/foo/zoo/loo";
TEST{url_add "/foo", "zoo//loo/." } "/foo/zoo/loo/";
TEST{url_add ".", "zoo/loo" } "zoo/loo"; # definitely
TEST_EXCEPTION {url_add ".", "../zoo/loo" }
  # "../zoo/loo"; # yes that's something I want, ok?
  "can't take '..' of root directory"; # well, ok?


fun url_diff ($path0from,$path0to) {
    my $from= $path0from=~ m|(.*?)/+$|s ? $1 : dirname $path0from;
    File::Spec->abs2rel($path0to, $from);
}

TEST{url_diff "foo/", "bar.css"} '../bar.css';
TEST{url_diff "foo/bar.html", "bar.css"} '../bar.css';
TEST{url_diff "foo", "bar.css"} 'bar.css';
#TEST{url_diff ".", "bar.css"} 'bar.css';

#/lib


{
    package PFLANZE::Cost;
    use FP::Array ":all";
    use FP::Struct [qw(name is_purchaseable basecosts val)];
    method cost ($index) {
	$$self{_cost} ||= do {
	    add($self->val,
		map {
		    $$index{$_}->cost ($index)
		} @{$self->basecosts}
	       );
	}
    }
    _END_
}
{
    package PFLANZE::Totalcost;
    use FP::Array_sort ":all";
    use FP::Struct [qw(costs)];
    method range () {
	@{$$self{costs}} or die "no costs given";#
	my $index;
	for (@{$$self{costs}}) {
	    if (defined (my $name= $_->name)) {
		$$index{$name}= $_
	    }
	}
	my $purchaseable= [grep { $_->is_purchaseable } @{$$self{costs}}];
	@$purchaseable or die "no purchaseable costs";#
	local our $all= array_sort
	  ( $purchaseable,
	    on the_method ("cost",$index), \&number_cmp );
	(@$all == 1
	 ? $$all[0]->cost ($index)
	 : $$all[0]->cost ($index)."..".$$all[-1]->cost($index)),
    }
    _END_
}


# group $files, to process them in an order that satisfies dependency
# on $costranges

fun groupkey ($path) {
    my $p0= path0 $path;
    if ($p0=~ m|^bugs/|) {
	"bugs"
    } elsif ($p0 =~ m|^docs/bugs.*\.md$|) {
	"buglist"
    } else {
	"normal"
    }
}


{
    package PFLANZE::Genfilestate;
    use FP::Struct [qw(filesinfo
			groupedfiles
			nonbugfiles
			costranges)];
    # ugly to keep that costranges state here ? well call it Genfilestate then?
    method set_costrange ($path0,$maybe_costrange) {
	$$self{costranges}{$path0}= $maybe_costrange;
    }
    method costrange ($path0) {
	$$self{costranges}{$path0}
    }
    _END_
}

fun get_genfilestate ($filesinfo) {
    my $groupedfiles= array2hash_group_by $filesinfo->files, \&groupkey;

    my $nonbugfiles= [@{$$groupedfiles{normal}},
		      @{$$groupedfiles{buglist}||[]}];

    my $costranges={};
    # path0 -> costrange-string; filled when processing non-buglist groups

    PFLANZE::Genfilestate->new ($filesinfo, # just so as to bundle it up, too, ugly?
			    $groupedfiles,
			    $nonbugfiles,
			    $costranges)
}

fun genfile ($path,$groupname,$genfilestate) {
    my $path0= path0 $path;
    my $outpath= path02outpath($path0);
    mkdir dirname( $outpath);

    my $filetitle= path02title $path0;

    my $str= xgetfile_utf8 "$inbase/$path";

    if ($$config{warn_hint}) {
	$str=~ s/^\(Check the.*?website.*?---\s+//s
	  or $path=~/COPYING|bugs\// or warn "'$path' is missing hint";
    }

    if (my $hdl= $config->{path0_handlers}->{$path0}) {
	$str= $hdl->($path,$path0,$str);
    }

    my $maybe_costrange= do {
	# extract Cost indicators:
	my $namere= qr/\w+/;
	my $nameplusre= qr/\(?$namere\)?/;
	my $perhaps_nameplus2name= fun ($maybe_nameplus) {
	    if (defined $maybe_nameplus) {
		my ($name)= $maybe_nameplus=~ qr/($namere)/
		  or die "bug";
		$name
	    } else {
		undef
	    }
	};
	local our $costs=[];
	while (#my ($name,$basecosts,$val)=
	       $str=~ m{\b[Cc]ost
			# name: parentheses for "library cost"
			(?:\s+($nameplusre))?
			:
			\s*
			# base costs
			((?:$nameplusre\s*\+\s*)*)
			\s*
			# amount
			\$\s*(\d+)
		   }gx) {
	    my ($nameplus,$basecosts,$val)=($1,$2,$3);# perl.
	    my $name= &$perhaps_nameplus2name($nameplus);
	    my @basecosts= map { &$perhaps_nameplus2name($_) }
	      split /\s*\+\s*/, $basecosts;
	    push @$costs, new PFLANZE::Cost ($name,
					 (not $nameplus
					  or not($nameplus=~ /^\(/)),
					 \@basecosts,
					 $val);
	}
	#local our $totalcost=
	#  PFLANZE::Totalcost->new($costs);
	#use Chj::Backtrace; use Chj::repl;repl if @$costs;#exit;
	@$costs ? PFLANZE::Totalcost->new($costs)->range : undef
    };
    if (defined $maybe_costrange) {
	$genfilestate->set_costrange($path0, $maybe_costrange);
    }

    my $htmlstr= markdown (mediawiki_expand $str);

    # XX hack: fix '<p><with_toc></p> .. <p></with_toc></p>' before
    # parsing, to avoid losing the with_toc element. Bah.
    $htmlstr=~ s|<p>\s*(</?with_toc[^<>]*>)\s*</p>|$1|sg;

    my $body= htmlparse($htmlstr, "body", $path0,
			$genfilestate->filesinfo);

    my ($h1,$body1)= do {
	my $body= $body->body;
	my ($maybe_h1, $rest)= pxml_body_split_h1 ($body);
	defined $maybe_h1 ? ($maybe_h1, $rest)
	  : (H1(path02title ($path0)), $body);
    };

    my $maybe_buglist= $groupname eq "buglist" && do {
	my $bugs=
	  array_sort
	    (array_map
	     (
	      fun ($path) {
		  my $path0= path0 $path;
		  my $title= path02title $path0;
		  [$title,$path0,$genfilestate->costrange($path0)]
	      },
	      $genfilestate->groupedfiles->{bugs}),
	     on sub{$_[0][0]}, \&string_cmp # XX not a good cmp.
	    );

	TABLE
	  ({class=> "costlist"},
	   THEAD (TH ("Type"), TH ("Title"),TH ("Cost range (USD)")),
	   map {
	       my ($title,$p0,$costrange)= @$_;
	       my $relurl= File::Spec->abs2rel(xsuffix_md2html($p0,0),
					       basename ($path0));
	       TR (TD (path02bugtype $p0),
		   TD (A({href=>$relurl},$title)),
		   TD ({align=>"center"},$costrange))
	   } @$bugs
	  )
    };

    puthtmlfile($outpath,
		HTML (
		      HEAD (
			    TITLE ($config->{title}->($filetitle)),
			    LINK ({rel=> "stylesheet",
				   href=> url_diff ($path0, $css_path),
				   type=> "text/css"}),
			    $config->{head}->($path0),
			   ),
		      BODY(
			   $config->{header}->($path0),
			   UL({class=> "menu"},
			      array_map_with_islast
			      (
			       fun ($is_last,$file0) {
				   my $filetitle= path02title $file0;
				   LI({class=> ($is_last ? "menu_last" : "menu")},
				      ($file0 eq $path0 ?
				       SPAN({class=> "menu_selected"},
					    $filetitle)
				       : A ({class=> "menu",
					     href=>
					     File::Spec->abs2rel
					     (xsuffix_md2html($file0,0),
					      dirname($path0))},
					    $filetitle)),
				      " ")
			       },
			       array_sort
			       (array_map( \&path0, $genfilestate->nonbugfiles),
				on $path02sortkey, \&string_cmp))),
			   $config->{belownav}->($path0),
			   $h1,
			   process_body ($body1),
			   $maybe_buglist,
			   BR,
			   HR,
			   ($maybe_costrange ? P("\x{21d2} Cost range: \$",
						 $maybe_costrange) : ()),
			   DIV({class=>"footer_date"}, author_date($path)))));
}


fun genfiles ($filesinfo) {
    my $genfilestate= get_genfilestate ($filesinfo);
    for my $groupname (qw(bugs normal buglist)) {
	for (@{$genfilestate->groupedfiles->{$groupname}}) {
	    genfile $_,$groupname,$genfilestate
	}
    }
}

# lib?
fun existingpath_or (@paths) {
    for (@paths) {
	return $_ if -e $_
    }
    die "none of the paths exist: @paths";
}


use POSIX qw(EEXIST ENOENT);

fun create_parent_dirs ($path0, $path02outpath) {
    my $path0= dirname $path0;
    my $outpath= &$path02outpath ($path0);
    if (mkdir $outpath) {
	# ok, return
    } elsif ($! == EEXIST) {
	# ok, return
    } elsif ($! == ENOENT) {
	create_parent_dirs ($path0, $path02outpath);
	xmkdir $outpath;
    } else {
	die "mkdir '$outpath': $!";
    }
}

# copy referenced non-.md files:
fun copyfiles ($filesinfo) {
    for my $path0 (hashset_keys
		   hashset_union($filesinfo->all_path0_used,
				 array2hashset($config->{copy_paths}))) {
	next if $filesinfo->path0_exists($path0); # md path
	next if $filesinfo->path0_is_directory($path0);
	create_parent_dirs ($path0, \&path02outpath);
	xcopyfile (path02inpath($path0), path02outpath($path0));
    }
    # copy CSS file
    xcopyfile (existingpath_or (path02inpath($css_path),
				path02inpath("htmlgen/$css_path")),
	       path02outpath($css_path));
}

fun main () {
    my $filesinfo= get_filesinfo;
    genfiles ($filesinfo);
    copyfiles ($filesinfo);
}


perhaps_run_tests __PACKAGE__
  or do {

    $opt_repl ? do {
	#require Chj::Backtrace; import Chj::Backtrace;
	require Chj::repl;
	Chj::repl::repl();
    } : main;

};

