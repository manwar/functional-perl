#!/usr/bin/env perl

#
# Copyright (c) 2014-2015 Christian Jaeger, copying@christianjaeger.ch
#
# This is free software, offered under either the same terms as perl 5
# or the terms of the Artistic License version 2 or the terms of the
# MIT License (Expat version). See the file COPYING.md that came
# bundled with this file.
#

use strict; use warnings; use warnings FATAL => 'uninitialized';

# XX this file should be split into modules

# Method::Signatures versions 20120523 and 20141021 are working badly
# for this file, because (1) each package needs its own import, (2)
# error locations are completely off. Thus, still use the trusty
# Function::Parameters.

use Function::Parameters qw(:strict);
use Sub::Call::Tail;

# find modules from functional-perl working directory (not installed)
use Cwd 'abs_path';
our ($mydir, $myname); BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/../lib";
# and the htmlgen/ directory
use lib $mydir;


our $css_path= "htmlgen.css";

sub usage {
    print "$myname config inbase outbase

  config is the path to a Perl file ending in a hash with config
  values, see gen-ml2json.pl for an example.

  inbase needs to be a git working directory.

  Assumes that there is a file '$css_path', which is included in the
  <head/> and copied to outbase.

  Options:
    --repl  open a repl instead of running the main action
    --trap  trap uncached exception in a repl (implied by --repl)

";
    exit 1;
}

use Getopt::Long;
our $verbose=0;
our ($opt_repl,$opt_trap);
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "repl"=> \$opt_repl,
	   "trap"=> \$opt_trap,
	   ) or exit 1;
usage unless @ARGV==3 or ($opt_repl and @ARGV>=1);

our ($configpath, $inbase, $outbase)= @ARGV;

our $user_config= require $configpath;

mkdir $outbase;

use Chj::Backtrace;
use Hash::Util 'lock_hash';
use Text::Markdown 'markdown';
use Chj::IO::Command;
use Chj::xperlfunc ':all';
use Chj::xopen ":all";
use Chj::chompspace;
use Chj::xIOUtil qw(xputfile_utf8 xgetfile_utf8 xcopyfile);
use FP::HashSet ":all";
use PXML::XHTML ":all";
use FP::Array ":all";
use File::Spec;
use FP::Array_sort;
use FP::Ops qw(string_cmp number_cmp the_method);
use Chj::TEST ":all";
use FP::List ":all";
use FP::Lazy ":all";
use FP::Stream ":all";
use PXML "is_pxml_element";
use PXML::Util ":all";
use FP::Hash ":all";
use FP::Div qw(identity inc dec);
use PXML::Tags qw(with_toc);
use FP::fix;
use FP::Combinators ":all";
use FP::Predicates;
use FP::Git::Repository;
use Htmlgen::PathTranslate;
use Htmlgen::PathUtil qw(path_add path_diff path0);
use Htmlgen::Mediawiki qw(mediawiki_expand);
use Htmlgen::Cost;
use Htmlgen::default_config qw($default_config);
use Htmlgen::UriUtil qw(URI_is_internal);


our $config = hashset_union ($user_config, $default_config);

lock_hash %$config;

our $pathtranslate= Htmlgen::PathTranslate->new__
  (subhash $config, "is_indexpath0", "downcaps");

our $gitrepository= FP::Git::Repository->new_(chdir=> $inbase);

fun path0_to_inpath ($path0) {
    "$inbase/".$path0
}

fun path0_to_outpath ($path0) {
    #"$outbase/".$pathtranslate->xsuffix_md_to_html($path0,0)
    # nope, also used for .pl file copying,
    "$outbase/".$pathtranslate->possibly_suffix_md_to_html($path0,0)
}

use HTML::TreeBuilder;
fun htmlparse_raw ($htmlstr,$whichtag) {
    my $t= HTML::TreeBuilder->new;
    $t->ignore_unknown(0); # allow <with_toc> elements
    $t->parse_content ($htmlstr);
    my $e= $t->elementify;
    # (^ actually mutates $t into the HTML::Element object already, ugh)
    $e->find_by_tag_name($whichtag)
}

# fix internal links, add anchors, .. in generated HTML, as well as
# convert it to PXML.
fun htmlmap ($e,$selfpath0,$filesinfo) {
    my $name= lc($e->tag);
    my $atts={};
    for ($e->all_external_attr_names) {
	next if $_ eq "/";
	die "att name '$_'" unless /^\w+\z/s;
	$$atts{lc $_}= $e->attr($_);
    }

    # fix internal .md links; should this be moved to the PXML mapping
    # phase now?
    if ($name eq "a"
	and URI_is_internal(my $uri= URI->new($$atts{href}))) {

	# check or find target, then convert to xhtml suffix
	my $path= $uri->path;

	# '//' feature (see doc-formatting.txt)
	if ($$atts{href} =~ m|^//|s) {
	    my ($op)= $uri->opaque() =~ m|^//([^/]+)$|s
	      or die "bug";
	    if (my ($p0)= $filesinfo->perhaps_filename_to_path0($op)) {
		$path= path_diff ($selfpath0,$p0); # mutation
	    } else {
		warn "unknown link target '$op' (from '$$atts{href}')";
		$path= path_diff ($selfpath0, "UNKNOWN/$op");
	    }
	    $uri->opaque(""); # mutation
	} else {
	    if (length $path) {
		my $p0= path_add(dirname ($selfpath0), $path);
		$p0=~ s|^\./||;#hack. grr y
		if ($filesinfo->all_path0_exists($p0)) {
		    $filesinfo->all_path0_used_inc($p0);
		} else {
		    warn "link target does not exist: '$p0' ".
		      "('$path' from '$selfpath0', link '$$atts{href}')";
		    #use Chj::repl;repl;
		}
	    }
	}
	if (length $path) {
	    $uri->path($pathtranslate->possibly_suffix_md_to_html ($path));
	}
	$$atts{href}= "$uri";# mutation.
    }

    my $res= PXML::Element->new
	($name,
	 $atts,
	 [
	  map {
	      if (ref $_) {
		  # another HTML::Element
		  no warnings "recursion";# XX should rather sanitize input?
		  htmlmap ($_,$selfpath0,$filesinfo)
	      } else {
		  # a string
		  $_
	      }
	  } @{$e->content||[]}
	 ]);
    # add anchors
    if ($name =~ /^h(\d)$/) {
	my $text= $res->text;
	$text=~ s/ /_/sg;
	A({name=> $text}, $res)
    } else {
	$res
    }
}

# parse HTML string to PXML, fixing up stuff at the same time (through
# htmlmap)
fun htmlparse ($str,$whichtag,$selfpath0,$filesinfo) {
    htmlmap htmlparse_raw ($str,$whichtag), $selfpath0, $filesinfo
}


# Return <h1> element if available, and rest. HACKY: compensate for
# 'add anchors'. XX Stupid: should add anchors *afterwards* instead.
fun pxml_body_split_h1 ($body) {
    my $rec= fix fun ($rec, $b) {
	if (is_null $b) {
	    (undef, $body)
	} else {
	    my ($v,$rest)= $b->first_and_rest;
	    if (is_pxml_element $v
		and $v->name eq "a"
		and defined $v->maybe_attribute("name")) {
		my $v2;
		if (($v2)= stream_mixed_flatten($v->body)->perhaps_one
		    and is_pxml_element $v2
		    and $v2->name eq "h1") {
		    ($v2, $rest)
		} else {
		    (undef, $body)
		}
	    } else {
		(undef, $body)
	    }
	}
    };
    &$rec (stream_mixed_flatten $body)
}

TEST{ [pxml_body_split_h1 ["foo"]] }
  [ undef, ['foo']];

TEST{ [pxml_body_split_h1 [H1 ("x"), "foo"]]->[0] }
  undef; # because we *really* expect the A wrapper now. stupid, again

TEST{
    my ($h1,$rest)=
      pxml_body_split_h1 [A({name=>"x"}, H1 ("x", "y")), "foo", B "bar"];
    [ $h1->string, BODY($rest)->string ]
}
  ['<h1>xy</h1>', '<body>foo<b>bar</b></body>'];




use Htmlgen::Toc;
use Htmlgen::Linking;

# XX make configurable
our $pxml_mappers=
  ["Htmlgen::Toc", "Htmlgen::Linking::code", "Htmlgen::Linking::a_href"];

fun pxml_name_to_mapper (@PXMLMapper_args) {
  +{
    map {
	my $m= $_->new(@PXMLMapper_args);
	($m->match_element_name, sub { $m->map_element(@_)})
    } @$pxml_mappers
   }
}


# dynamic passing only so that process_body can be tested easily
our $current_pxml_name_to_mapper=
  # fake instance for tests only:
  pxml_name_to_mapper ("NOPATH", sub{die"NOIMPL"});


fun process_body ($v) {
    pxml_map_elements ($v, $current_pxml_name_to_mapper)
}

TEST { HTML( process_body
	     (["Hello",
	       WITH_TOC({level=>1},
			A({name=>"wo"}, H1 "world"))]))
	 ->string }
  '<html>Hello<div class="toc_box"><dir class="toc"><h3 class="toc_title">Contents</h3><li><dir class="toc"><a href="#wo">1. world</a></dir></li></dir></div><a name="wo"><h1>1. world</h1></a></html>';

TEST { HTML( process_body
	     (["Hello", WITH_TOC ["some", A {name=>"a"}, H2 "world"]]))
	 ->string }
  '<html>Hello<div class="toc_box"><dir class="toc"><h3 class="toc_title">Contents</h3><li><dir class="toc"><a href="#a">1. world</a></dir></li></dir></div>some<a name="a"><h2>1. world</h2></a></html>';

TEST { HTML( process_body  ([P("Hello"),
			     WITH_TOC
			     {level=>1},
			     [" ",
			      P ("blabla"),
			      A({name=>"a"}," ",DIV H1 ("for one")),
			     ]]))->string }
  '<html><p>Hello</p><div class="toc_box"><dir class="toc"><h3 class="toc_title">Contents</h3><li><dir class="toc"><a href="#a">1. for one</a></dir></li></dir></div> <p>blabla</p><a name="a"> <div><h1>1. for one</h1></div></a></html>';

TEST { HTML( process_body  ([P("Hello"),
			     WITH_TOC
			     {level=>1},
			     [" ",
			      P ("blabla"),
			      A({name=>"a"}, H1 ("for one")),
			      A({name=>"b"}, H2 ("more one")),
			      TABLE(TR
				    TD
				    P ("blah"),
				    A ({name=>"c"}, H1 ("sub two")),
				    DIV ("bla")),
			     ]]))->string }
  '<html><p>Hello</p>'.
  '<div class="toc_box"><dir class="toc"><h3 class="toc_title">Contents</h3><li><dir class="toc"><a href="#a">1. for one</a><li><dir class="toc"><a href="#b">1.1. more one</a></dir></li></dir></li><li><dir class="toc"><a href="#c">2. sub two</a></dir></li></dir></div>'.
  ' <p>blabla</p><a name="a"><h1>1. for one</h1></a><a name="b"><h2>1.1. more one</h2></a><table><tr><td><p>blah</p><a name="c"><h1>2. sub two</h1></a><div>bla</div></td></tr></table></html>';


use PXML::Serialize 'pxml_xhtml_print_fast';

# v- is now in PXML::Serialize, too, except for the xmkdir_p
fun puthtmlfile ($path,$p) {
    xmkdir_p dirname $path;
    my $out= xopen_write($path);
    binmode $out, ":utf8" or die;
    pxml_xhtml_print_fast($p, $out, "en");# hard coded lang
    $out->xclose;
}



{
    package PFLANZE::Filesinfo;
    use FP::Hash "hash_perhaps_ref";
    use FP::Struct [qw(files
			filename_to_path0
			all_path0_exists
			path0_exists
			all_path0_used
		      )];
    method filename_to_path0 ($filename) {
	$$self{filename_to_path0}{$filename}
	  // die "no mapping for filename '$filename'"
    }
    method filename_to_maybe_path0 ($filename) {
	$$self{filename_to_path0}{$filename}
    }
    # still very unclear about the exact name styling. Prefer perhaps,
    # and "then" also move the qualificator to the front? (but leave
    # the one for hash_ where it is since hash_ is the type prefix?) :
    method perhaps_filename_to_path0 ($filename) {
	hash_perhaps_ref ($$self{filename_to_path0}, $filename)
    }
    method all_path0_exists ($path0) {
	defined $$self{all_path0_exists}{$path0}
	  or
	defined $$self{all_path0_exists}{$path0."/"}
    }
    method path0_is_directory ($path0) {
	$path0=~ s|/+$||s;
	defined $$self{all_path0_exists}{$path0."/"}
    }
    method path0_exists ($path0) {
	defined $$self{path0_exists}{$path0}
    }
    method all_path0_used_inc ($path0) {
	$$self{all_path0_used}{$path0}++
    }
    _END_
}

fun get_filesinfo () {
    my $all_files= $gitrepository->ls_files->array;

    my $files= [grep {
	/\.md$/
    } @$all_files];

    my $filename_to_path0=
      +{map {
	  basename ($_)=> path0($_)
      } @$files};

    my $all_path0_exists=
      +{
	map {
	    path0($_)=>1
	}
	@$all_files,
	# and their directories, ok? Any directory that has files
	# from git will be ok as link target, ok?
	map {
	    dirname($_)."/"
	}
	@$all_files
       };

    my $path0_exists=
      +{map {
	  path0($_)=>1
      } @$files};

    my $all_path0_used= {};

    PFLANZE::Filesinfo->new($files,
			$filename_to_path0,
			$all_path0_exists,
			$path0_exists,
			$all_path0_used)
}


# Navigation:

# currently only show the toplevel of the nav hierarchy (pages listed
# in lower levels in the hierarchy are *not* shown at all)
our $nav_toplevel= array_map *array_first, $config->{nav};

# all pages in lower hierarchies:
our $pages_in_lower_hierarchies=
  mixed_flatten (array_map (*array_rest, $config->{nav}))->array;
our $page_is_in_lower_hierarchy=
  hashset_to_predicate array_to_hashset $pages_in_lower_hierarchies;

# still also show pages that are missing in the nav declaration; thus,
# use the nav declaration to *order* the pages instead:
our $path0_to_sortkey= do {
    my $sortprio= do {
	my $i=1;
	+{
	  map {
	      my $file= $_;
	      $file.= ".md" unless /\.\w{1,7}\z/;
	      $file=> sprintf('-%04d', $i++)
	  } @$nav_toplevel
	 }
    };
    fun ($path0) {
	$$sortprio{$path0} || $path0
    }
};

fun _path0_to_title_mod ($str) {
    $str=~ s/_/ /sg;
    ucfirst $str
}

fun path0_to_title ($path0) {
    my $dn= dirname($path0);
    if ($dn ne "." and $$config{is_indexpath0}->($path0)) {
	_path0_to_title_mod
	  basename ( $pathtranslate->xsuffix_md_to_html($dn.".md",1), ".xhtml");
    } else {
	_path0_to_title_mod
	  basename( $pathtranslate->xsuffix_md_to_html ($path0,1),".xhtml");
    }
}

TEST{path0_to_title "README.md"} 'Readme';
TEST{path0_to_title "bugs/wishlist/listserv/index.md"} 'Listserv';
TEST{path0_to_title "bugs/wishlist/listserv/README.md"} 'Listserv';
TEST{path0_to_title "bugs/wishlist/listserv/other.md"} 'Other';
use FP::Predicates 'false';
TEST{
    local $config= +{is_indexpath0=> *false};
    path0_to_title "bugs/wishlist/listserv/README.md"
}
  'Readme';
TEST{path0_to_title "bugs/wishlist/line_wrapping_in_pre-MIME_mails.md"}
  # even with lcfirst
  'Line wrapping in pre-MIME mails';


fun path0_to_bugtype ($path0) {
    $path0=~ m|\bbugs/([^/]+)/| or die "no match, '$path0'";
    ucfirst $1
}




# group $files, to process them in an order that satisfies dependency
# on $costranges

fun groupkey ($path) {
    my $p0= path0 $path;
    if ($p0=~ m|^bugs/|) {
	"bugs"
    } elsif ($p0 =~ m|^docs/bugs.*\.md$|) {
	"buglist"
    } else {
	"normal"
    }
}


{
    package PFLANZE::Genfilestate;
    use FP::Struct [qw(filesinfo
			groupedfiles
			nonbugfiles
			costranges)];
    # ugly to keep that costranges state here ? well call it Genfilestate then?
    method set_costrange ($path0,$maybe_costrange) {
	$$self{costranges}{$path0}= $maybe_costrange;
    }
    method costrange ($path0) {
	$$self{costranges}{$path0}
    }
    _END_
}

fun get_genfilestate ($filesinfo) {
    my $groupedfiles= array_to_hash_group_by $filesinfo->files, \&groupkey;

    my $nonbugfiles= [@{$$groupedfiles{normal}},
		      @{$$groupedfiles{buglist}||[]}];

    my $costranges={};
    # path0 -> costrange-string; filled when processing non-buglist groups

    PFLANZE::Genfilestate->new
	($filesinfo, # just so as to bundle it up, too, ugly?
	 $groupedfiles,
	 $nonbugfiles,
	 $costranges)
}

fun genfile ($path,$groupname,$genfilestate) {
    my $path0= path0 $path;
    my $outpath= path0_to_outpath($path0);
    mkdir dirname( $outpath);

    my $filetitle= path0_to_title $path0;

    my $str= xgetfile_utf8 "$inbase/$path";

    if ($$config{warn_hint}) {
	$str=~ s/^\(?Check the.*?website.*?---\s+//s
	  or $path=~/COPYING|bugs|licenses\//
	    or warn "'$path' is missing hint";
    }

    if (my $hdl= $config->{path0_handlers}->{$path0}) {
	$str= $hdl->($path,$path0,$str);
    }

    my $maybe_costrange= do {
	# extract Cost indicators:
	my $namere= qr/\w+/;
	my $nameplusre= qr/\(?$namere\)?/;
	my $possibly_nameplus_to_name= fun ($maybe_nameplus) {
	    if (defined $maybe_nameplus) {
		my ($name)= $maybe_nameplus=~ qr/($namere)/
		  or die "bug";
		$name
	    } else {
		undef
	    }
	};
	local our $costs=[];
	while (#my ($name,$basecosts,$val)=
	       $str=~ m{\b[Cc]ost
			# name: parentheses for "library cost"
			(?:\s+($nameplusre))?
			:
			\s*
			# base costs
			((?:$nameplusre\s*\+\s*)*)
			\s*
			# amount
			\$\s*(\d+)
		   }gx) {
	    my ($nameplus,$basecosts,$val)=($1,$2,$3);# perl.
	    my $name= &$possibly_nameplus_to_name($nameplus);
	    my @basecosts= map { &$possibly_nameplus_to_name($_) }
	      split /\s*\+\s*/, $basecosts;
	    push @$costs, new PFLANZE::Cost ($name,
					 (not $nameplus
					  or not($nameplus=~ /^\(/)),
					 \@basecosts,
					 $val);
	}
	#local our $totalcost=
	#  PFLANZE::Totalcost->new($costs);
	#use Chj::Backtrace; use Chj::repl;repl if @$costs;#exit;
	@$costs ? PFLANZE::Totalcost->new($costs)->range : undef
    };
    if (defined $maybe_costrange) {
	$genfilestate->set_costrange($path0, $maybe_costrange);
    }

    my $htmlstr= markdown (mediawiki_expand $str);

    # XX hack: fix '<p><with_toc></p> .. <p></with_toc></p>' before
    # parsing, to avoid losing the with_toc element. Bah.
    $htmlstr=~ s|<p>\s*(</?with_toc[^<>]*>)\s*</p>|$1|sg;

    my $body= htmlparse($htmlstr, "body", $path0,
			$genfilestate->filesinfo);

    my ($h1,$body1)= do {
	my $body= $body->body;
	my ($maybe_h1, $rest)= pxml_body_split_h1 ($body);
	defined $maybe_h1 ? ($maybe_h1, $rest)
	  : (H1(path0_to_title ($path0)), $body);
    };

    my $maybe_buglist= $groupname eq "buglist" && do {
	my $bugs=
	  array_sort
	    (array_map
	     (
	      fun ($path) {
		  my $path0= path0 $path;
		  my $title= path0_to_title $path0;
		  [$title,$path0,$genfilestate->costrange($path0)]
	      },
	      $genfilestate->groupedfiles->{bugs}),
	     on sub{$_[0][0]}, \&string_cmp # XX not a good cmp.
	    );

	TABLE
	  ({class=> "costlist"},
	   THEAD (TH ("Type"), TH ("Title"),TH ("Cost range (USD)")),
	   map {
	       my ($title,$p0,$costrange)= @$_;
	       my $relurl= File::Spec->abs2rel($pathtranslate->xsuffix_md_to_html($p0,0),
					       basename ($path0));
	       TR (TD (path0_to_bugtype $p0),
		   TD (A({href=>$relurl},$title)),
		   TD ({align=>"center"},$costrange))
	   } @$bugs
	  )
    };

    my $filesinfo= $genfilestate->filesinfo;
    # pass values to html mappers:  XX hacky?
    local $current_pxml_name_to_mapper=
      pxml_name_to_mapper ($path0,
			   fun ($path0) {
			       if ($filesinfo->all_path0_exists ($path0)) {
				   $filesinfo->all_path0_used_inc($path0);
				   $path0
			       } else {
				   undef
			       }
			   },
			   hash_maybe_ref ($config, "map_code_body"),
			  );

    my $html=
      HTML (
	    HEAD (
		  TITLE ($config->{title}->($filetitle)),
		  LINK ({rel=> "stylesheet",
			 href=> path_diff ($path0, $css_path),
			 type=> "text/css"}),
		  $config->{head}->($path0),
		 ),
	    BODY(
		 $config->{header}->($path0),
		 UL({class=> "menu"},
		    array_map_with_islast
		    (
		     fun ($is_last,$file0) {
			 my $filetitle= path0_to_title $file0;
			 LI({class=> ($is_last ? "menu_last"
				      : "menu")},
			    ($file0 eq $path0 ?
			     SPAN({class=> "menu_selected"},
				  $filetitle)
			     : A ({class=> "menu",
				   href=>
				   File::Spec->abs2rel
				   ($pathtranslate->xsuffix_md_to_html($file0,0),
				    dirname($path0))},
				  $filetitle)),
			    " ")
		     },
		     array_sort
		     (array_filter(complement($page_is_in_lower_hierarchy),
				   array_map (\&path0, $genfilestate->nonbugfiles)),
		      on $path0_to_sortkey, \&string_cmp))),
		 $config->{belownav}->($path0),
		 $h1,
		 process_body ($body1),
		 $maybe_buglist,
		 BR,
		 HR,
		 ($maybe_costrange ? P("\x{21d2} Cost range: \$",
				       $maybe_costrange) : ()),
		 DIV({class=>"footer_date"},
		     $gitrepository->xauthor_date ($path)),
		 $config->{footer}->($path0)));

    puthtmlfile($outpath, $html);
}


fun genfiles ($filesinfo) {
    my $genfilestate= get_genfilestate ($filesinfo);
    for my $groupname (qw(bugs normal buglist)) {
	for (@{$genfilestate->groupedfiles->{$groupname}}) {
	    genfile $_,$groupname,$genfilestate
	}
    }
}

# lib?
fun existingpath_or (@paths) {
    for (@paths) {
	return $_ if -e $_
    }
    die "none of the paths exist: @paths";
}


use POSIX qw(EEXIST ENOENT);

fun create_parent_dirs ($path0, $path0_to_outpath) {
    my $path0= dirname $path0;
    my $outpath= &$path0_to_outpath ($path0);
    if (mkdir $outpath) {
	# ok, return
    } elsif ($! == EEXIST) {
	# ok, return
    } elsif ($! == ENOENT) {
	create_parent_dirs ($path0, $path0_to_outpath);
	xmkdir $outpath;
    } else {
	die "mkdir '$outpath': $!";
    }
}

# copy referenced non-.md files:
fun copyfiles ($filesinfo) {
    for my $path0 (hashset_keys
		   hashset_union($filesinfo->all_path0_used,
				 array_to_hashset
				 (hash_ref_or ($config, "copy_paths", [])))) {
	next if $filesinfo->path0_exists($path0); # md path
	next if $filesinfo->path0_is_directory($path0);
	create_parent_dirs ($path0, \&path0_to_outpath);
	xcopyfile (path0_to_inpath($path0), path0_to_outpath($path0));
    }
    if (my ($separate)= hash_perhaps_ref($config, "copy_paths_separate")) {
	for my $root (keys %$separate) {
	    for my $path0 (@{$$separate{$root}}) {
		xcopyfile "$root/$path0", path0_to_outpath $path0
	    }
	}
    }
    # copy htmlgen CSS file
    xcopyfile (existingpath_or (path0_to_inpath($css_path),
				path0_to_inpath("htmlgen/$css_path")),
	       path0_to_outpath($css_path));
}

fun main () {
    my $filesinfo= get_filesinfo;
    genfiles ($filesinfo);
    copyfiles ($filesinfo);
}


perhaps_run_tests __PACKAGE__
  or do {
      if ($opt_trap) {
	  require Chj::WithRepl; &Chj::WithRepl::push_withrepl (0);
      }

      $opt_repl ? do {
	  require Chj::repl;
	  require Chj::WithRepl; &Chj::WithRepl::push_withrepl (0);
	  Chj::repl::repl();
      } : main;
};

